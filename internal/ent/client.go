// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/bengobox/auth-api/internal/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/bengobox/auth-api/internal/ent/auditlog"
	"github.com/bengobox/auth-api/internal/ent/authorizationcode"
	"github.com/bengobox/auth-api/internal/ent/consentsession"
	"github.com/bengobox/auth-api/internal/ent/featureentitlement"
	"github.com/bengobox/auth-api/internal/ent/integrationconfig"
	"github.com/bengobox/auth-api/internal/ent/loginattempt"
	"github.com/bengobox/auth-api/internal/ent/mfabackupcode"
	"github.com/bengobox/auth-api/internal/ent/mfasettings"
	"github.com/bengobox/auth-api/internal/ent/mfatotpsecret"
	"github.com/bengobox/auth-api/internal/ent/oauthclient"
	"github.com/bengobox/auth-api/internal/ent/passwordresettoken"
	"github.com/bengobox/auth-api/internal/ent/session"
	"github.com/bengobox/auth-api/internal/ent/tenant"
	"github.com/bengobox/auth-api/internal/ent/tenantmembership"
	"github.com/bengobox/auth-api/internal/ent/usagemetric"
	"github.com/bengobox/auth-api/internal/ent/user"
	"github.com/bengobox/auth-api/internal/ent/useridentity"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// AuthorizationCode is the client for interacting with the AuthorizationCode builders.
	AuthorizationCode *AuthorizationCodeClient
	// ConsentSession is the client for interacting with the ConsentSession builders.
	ConsentSession *ConsentSessionClient
	// FeatureEntitlement is the client for interacting with the FeatureEntitlement builders.
	FeatureEntitlement *FeatureEntitlementClient
	// IntegrationConfig is the client for interacting with the IntegrationConfig builders.
	IntegrationConfig *IntegrationConfigClient
	// LoginAttempt is the client for interacting with the LoginAttempt builders.
	LoginAttempt *LoginAttemptClient
	// MFABackupCode is the client for interacting with the MFABackupCode builders.
	MFABackupCode *MFABackupCodeClient
	// MFASettings is the client for interacting with the MFASettings builders.
	MFASettings *MFASettingsClient
	// MFATOTPSecret is the client for interacting with the MFATOTPSecret builders.
	MFATOTPSecret *MFATOTPSecretClient
	// OAuthClient is the client for interacting with the OAuthClient builders.
	OAuthClient *OAuthClientClient
	// PasswordResetToken is the client for interacting with the PasswordResetToken builders.
	PasswordResetToken *PasswordResetTokenClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Tenant is the client for interacting with the Tenant builders.
	Tenant *TenantClient
	// TenantMembership is the client for interacting with the TenantMembership builders.
	TenantMembership *TenantMembershipClient
	// UsageMetric is the client for interacting with the UsageMetric builders.
	UsageMetric *UsageMetricClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserIdentity is the client for interacting with the UserIdentity builders.
	UserIdentity *UserIdentityClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuditLog = NewAuditLogClient(c.config)
	c.AuthorizationCode = NewAuthorizationCodeClient(c.config)
	c.ConsentSession = NewConsentSessionClient(c.config)
	c.FeatureEntitlement = NewFeatureEntitlementClient(c.config)
	c.IntegrationConfig = NewIntegrationConfigClient(c.config)
	c.LoginAttempt = NewLoginAttemptClient(c.config)
	c.MFABackupCode = NewMFABackupCodeClient(c.config)
	c.MFASettings = NewMFASettingsClient(c.config)
	c.MFATOTPSecret = NewMFATOTPSecretClient(c.config)
	c.OAuthClient = NewOAuthClientClient(c.config)
	c.PasswordResetToken = NewPasswordResetTokenClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Tenant = NewTenantClient(c.config)
	c.TenantMembership = NewTenantMembershipClient(c.config)
	c.UsageMetric = NewUsageMetricClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserIdentity = NewUserIdentityClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		AuditLog:           NewAuditLogClient(cfg),
		AuthorizationCode:  NewAuthorizationCodeClient(cfg),
		ConsentSession:     NewConsentSessionClient(cfg),
		FeatureEntitlement: NewFeatureEntitlementClient(cfg),
		IntegrationConfig:  NewIntegrationConfigClient(cfg),
		LoginAttempt:       NewLoginAttemptClient(cfg),
		MFABackupCode:      NewMFABackupCodeClient(cfg),
		MFASettings:        NewMFASettingsClient(cfg),
		MFATOTPSecret:      NewMFATOTPSecretClient(cfg),
		OAuthClient:        NewOAuthClientClient(cfg),
		PasswordResetToken: NewPasswordResetTokenClient(cfg),
		Session:            NewSessionClient(cfg),
		Tenant:             NewTenantClient(cfg),
		TenantMembership:   NewTenantMembershipClient(cfg),
		UsageMetric:        NewUsageMetricClient(cfg),
		User:               NewUserClient(cfg),
		UserIdentity:       NewUserIdentityClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		AuditLog:           NewAuditLogClient(cfg),
		AuthorizationCode:  NewAuthorizationCodeClient(cfg),
		ConsentSession:     NewConsentSessionClient(cfg),
		FeatureEntitlement: NewFeatureEntitlementClient(cfg),
		IntegrationConfig:  NewIntegrationConfigClient(cfg),
		LoginAttempt:       NewLoginAttemptClient(cfg),
		MFABackupCode:      NewMFABackupCodeClient(cfg),
		MFASettings:        NewMFASettingsClient(cfg),
		MFATOTPSecret:      NewMFATOTPSecretClient(cfg),
		OAuthClient:        NewOAuthClientClient(cfg),
		PasswordResetToken: NewPasswordResetTokenClient(cfg),
		Session:            NewSessionClient(cfg),
		Tenant:             NewTenantClient(cfg),
		TenantMembership:   NewTenantMembershipClient(cfg),
		UsageMetric:        NewUsageMetricClient(cfg),
		User:               NewUserClient(cfg),
		UserIdentity:       NewUserIdentityClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuditLog.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuditLog, c.AuthorizationCode, c.ConsentSession, c.FeatureEntitlement,
		c.IntegrationConfig, c.LoginAttempt, c.MFABackupCode, c.MFASettings,
		c.MFATOTPSecret, c.OAuthClient, c.PasswordResetToken, c.Session, c.Tenant,
		c.TenantMembership, c.UsageMetric, c.User, c.UserIdentity,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuditLog, c.AuthorizationCode, c.ConsentSession, c.FeatureEntitlement,
		c.IntegrationConfig, c.LoginAttempt, c.MFABackupCode, c.MFASettings,
		c.MFATOTPSecret, c.OAuthClient, c.PasswordResetToken, c.Session, c.Tenant,
		c.TenantMembership, c.UsageMetric, c.User, c.UserIdentity,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *AuthorizationCodeMutation:
		return c.AuthorizationCode.mutate(ctx, m)
	case *ConsentSessionMutation:
		return c.ConsentSession.mutate(ctx, m)
	case *FeatureEntitlementMutation:
		return c.FeatureEntitlement.mutate(ctx, m)
	case *IntegrationConfigMutation:
		return c.IntegrationConfig.mutate(ctx, m)
	case *LoginAttemptMutation:
		return c.LoginAttempt.mutate(ctx, m)
	case *MFABackupCodeMutation:
		return c.MFABackupCode.mutate(ctx, m)
	case *MFASettingsMutation:
		return c.MFASettings.mutate(ctx, m)
	case *MFATOTPSecretMutation:
		return c.MFATOTPSecret.mutate(ctx, m)
	case *OAuthClientMutation:
		return c.OAuthClient.mutate(ctx, m)
	case *PasswordResetTokenMutation:
		return c.PasswordResetToken.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *TenantMutation:
		return c.Tenant.mutate(ctx, m)
	case *TenantMembershipMutation:
		return c.TenantMembership.mutate(ctx, m)
	case *UsageMetricMutation:
		return c.UsageMetric.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserIdentityMutation:
		return c.UserIdentity.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id uuid.UUID) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id uuid.UUID) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id uuid.UUID) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id uuid.UUID) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// AuthorizationCodeClient is a client for the AuthorizationCode schema.
type AuthorizationCodeClient struct {
	config
}

// NewAuthorizationCodeClient returns a client for the AuthorizationCode from the given config.
func NewAuthorizationCodeClient(c config) *AuthorizationCodeClient {
	return &AuthorizationCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizationcode.Hooks(f(g(h())))`.
func (c *AuthorizationCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthorizationCode = append(c.hooks.AuthorizationCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizationcode.Intercept(f(g(h())))`.
func (c *AuthorizationCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizationCode = append(c.inters.AuthorizationCode, interceptors...)
}

// Create returns a builder for creating a AuthorizationCode entity.
func (c *AuthorizationCodeClient) Create() *AuthorizationCodeCreate {
	mutation := newAuthorizationCodeMutation(c.config, OpCreate)
	return &AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizationCode entities.
func (c *AuthorizationCodeClient) CreateBulk(builders ...*AuthorizationCodeCreate) *AuthorizationCodeCreateBulk {
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorizationCodeClient) MapCreateBulk(slice any, setFunc func(*AuthorizationCodeCreate, int)) *AuthorizationCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorizationCodeCreateBulk{err: fmt.Errorf("calling to AuthorizationCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorizationCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorizationCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Update() *AuthorizationCodeUpdate {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdate)
	return &AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizationCodeClient) UpdateOne(_m *AuthorizationCode) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCode(_m))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizationCodeClient) UpdateOneID(id uuid.UUID) *AuthorizationCodeUpdateOne {
	mutation := newAuthorizationCodeMutation(c.config, OpUpdateOne, withAuthorizationCodeID(id))
	return &AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Delete() *AuthorizationCodeDelete {
	mutation := newAuthorizationCodeMutation(c.config, OpDelete)
	return &AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizationCodeClient) DeleteOne(_m *AuthorizationCode) *AuthorizationCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizationCodeClient) DeleteOneID(id uuid.UUID) *AuthorizationCodeDeleteOne {
	builder := c.Delete().Where(authorizationcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizationCodeDeleteOne{builder}
}

// Query returns a query builder for AuthorizationCode.
func (c *AuthorizationCodeClient) Query() *AuthorizationCodeQuery {
	return &AuthorizationCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizationCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizationCode entity by its id.
func (c *AuthorizationCodeClient) Get(ctx context.Context, id uuid.UUID) (*AuthorizationCode, error) {
	return c.Query().Where(authorizationcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizationCodeClient) GetX(ctx context.Context, id uuid.UUID) *AuthorizationCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AuthorizationCode.
func (c *AuthorizationCodeClient) QueryUser(_m *AuthorizationCode) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizationcode.Table, authorizationcode.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, authorizationcode.UserTable, authorizationcode.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizationCodeClient) Hooks() []Hook {
	return c.hooks.AuthorizationCode
}

// Interceptors returns the client interceptors.
func (c *AuthorizationCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthorizationCode
}

func (c *AuthorizationCodeClient) mutate(ctx context.Context, m *AuthorizationCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizationCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizationCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizationCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizationCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizationCode mutation op: %q", m.Op())
	}
}

// ConsentSessionClient is a client for the ConsentSession schema.
type ConsentSessionClient struct {
	config
}

// NewConsentSessionClient returns a client for the ConsentSession from the given config.
func NewConsentSessionClient(c config) *ConsentSessionClient {
	return &ConsentSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `consentsession.Hooks(f(g(h())))`.
func (c *ConsentSessionClient) Use(hooks ...Hook) {
	c.hooks.ConsentSession = append(c.hooks.ConsentSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `consentsession.Intercept(f(g(h())))`.
func (c *ConsentSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConsentSession = append(c.inters.ConsentSession, interceptors...)
}

// Create returns a builder for creating a ConsentSession entity.
func (c *ConsentSessionClient) Create() *ConsentSessionCreate {
	mutation := newConsentSessionMutation(c.config, OpCreate)
	return &ConsentSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConsentSession entities.
func (c *ConsentSessionClient) CreateBulk(builders ...*ConsentSessionCreate) *ConsentSessionCreateBulk {
	return &ConsentSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConsentSessionClient) MapCreateBulk(slice any, setFunc func(*ConsentSessionCreate, int)) *ConsentSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConsentSessionCreateBulk{err: fmt.Errorf("calling to ConsentSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConsentSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConsentSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConsentSession.
func (c *ConsentSessionClient) Update() *ConsentSessionUpdate {
	mutation := newConsentSessionMutation(c.config, OpUpdate)
	return &ConsentSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConsentSessionClient) UpdateOne(_m *ConsentSession) *ConsentSessionUpdateOne {
	mutation := newConsentSessionMutation(c.config, OpUpdateOne, withConsentSession(_m))
	return &ConsentSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConsentSessionClient) UpdateOneID(id uuid.UUID) *ConsentSessionUpdateOne {
	mutation := newConsentSessionMutation(c.config, OpUpdateOne, withConsentSessionID(id))
	return &ConsentSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConsentSession.
func (c *ConsentSessionClient) Delete() *ConsentSessionDelete {
	mutation := newConsentSessionMutation(c.config, OpDelete)
	return &ConsentSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConsentSessionClient) DeleteOne(_m *ConsentSession) *ConsentSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConsentSessionClient) DeleteOneID(id uuid.UUID) *ConsentSessionDeleteOne {
	builder := c.Delete().Where(consentsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConsentSessionDeleteOne{builder}
}

// Query returns a query builder for ConsentSession.
func (c *ConsentSessionClient) Query() *ConsentSessionQuery {
	return &ConsentSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConsentSession},
		inters: c.Interceptors(),
	}
}

// Get returns a ConsentSession entity by its id.
func (c *ConsentSessionClient) Get(ctx context.Context, id uuid.UUID) (*ConsentSession, error) {
	return c.Query().Where(consentsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConsentSessionClient) GetX(ctx context.Context, id uuid.UUID) *ConsentSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConsentSessionClient) Hooks() []Hook {
	return c.hooks.ConsentSession
}

// Interceptors returns the client interceptors.
func (c *ConsentSessionClient) Interceptors() []Interceptor {
	return c.inters.ConsentSession
}

func (c *ConsentSessionClient) mutate(ctx context.Context, m *ConsentSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConsentSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConsentSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConsentSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConsentSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConsentSession mutation op: %q", m.Op())
	}
}

// FeatureEntitlementClient is a client for the FeatureEntitlement schema.
type FeatureEntitlementClient struct {
	config
}

// NewFeatureEntitlementClient returns a client for the FeatureEntitlement from the given config.
func NewFeatureEntitlementClient(c config) *FeatureEntitlementClient {
	return &FeatureEntitlementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featureentitlement.Hooks(f(g(h())))`.
func (c *FeatureEntitlementClient) Use(hooks ...Hook) {
	c.hooks.FeatureEntitlement = append(c.hooks.FeatureEntitlement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featureentitlement.Intercept(f(g(h())))`.
func (c *FeatureEntitlementClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeatureEntitlement = append(c.inters.FeatureEntitlement, interceptors...)
}

// Create returns a builder for creating a FeatureEntitlement entity.
func (c *FeatureEntitlementClient) Create() *FeatureEntitlementCreate {
	mutation := newFeatureEntitlementMutation(c.config, OpCreate)
	return &FeatureEntitlementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeatureEntitlement entities.
func (c *FeatureEntitlementClient) CreateBulk(builders ...*FeatureEntitlementCreate) *FeatureEntitlementCreateBulk {
	return &FeatureEntitlementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureEntitlementClient) MapCreateBulk(slice any, setFunc func(*FeatureEntitlementCreate, int)) *FeatureEntitlementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureEntitlementCreateBulk{err: fmt.Errorf("calling to FeatureEntitlementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureEntitlementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureEntitlementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeatureEntitlement.
func (c *FeatureEntitlementClient) Update() *FeatureEntitlementUpdate {
	mutation := newFeatureEntitlementMutation(c.config, OpUpdate)
	return &FeatureEntitlementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureEntitlementClient) UpdateOne(_m *FeatureEntitlement) *FeatureEntitlementUpdateOne {
	mutation := newFeatureEntitlementMutation(c.config, OpUpdateOne, withFeatureEntitlement(_m))
	return &FeatureEntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureEntitlementClient) UpdateOneID(id uuid.UUID) *FeatureEntitlementUpdateOne {
	mutation := newFeatureEntitlementMutation(c.config, OpUpdateOne, withFeatureEntitlementID(id))
	return &FeatureEntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeatureEntitlement.
func (c *FeatureEntitlementClient) Delete() *FeatureEntitlementDelete {
	mutation := newFeatureEntitlementMutation(c.config, OpDelete)
	return &FeatureEntitlementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureEntitlementClient) DeleteOne(_m *FeatureEntitlement) *FeatureEntitlementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureEntitlementClient) DeleteOneID(id uuid.UUID) *FeatureEntitlementDeleteOne {
	builder := c.Delete().Where(featureentitlement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureEntitlementDeleteOne{builder}
}

// Query returns a query builder for FeatureEntitlement.
func (c *FeatureEntitlementClient) Query() *FeatureEntitlementQuery {
	return &FeatureEntitlementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeatureEntitlement},
		inters: c.Interceptors(),
	}
}

// Get returns a FeatureEntitlement entity by its id.
func (c *FeatureEntitlementClient) Get(ctx context.Context, id uuid.UUID) (*FeatureEntitlement, error) {
	return c.Query().Where(featureentitlement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureEntitlementClient) GetX(ctx context.Context, id uuid.UUID) *FeatureEntitlement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeatureEntitlementClient) Hooks() []Hook {
	return c.hooks.FeatureEntitlement
}

// Interceptors returns the client interceptors.
func (c *FeatureEntitlementClient) Interceptors() []Interceptor {
	return c.inters.FeatureEntitlement
}

func (c *FeatureEntitlementClient) mutate(ctx context.Context, m *FeatureEntitlementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureEntitlementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureEntitlementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureEntitlementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureEntitlementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeatureEntitlement mutation op: %q", m.Op())
	}
}

// IntegrationConfigClient is a client for the IntegrationConfig schema.
type IntegrationConfigClient struct {
	config
}

// NewIntegrationConfigClient returns a client for the IntegrationConfig from the given config.
func NewIntegrationConfigClient(c config) *IntegrationConfigClient {
	return &IntegrationConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `integrationconfig.Hooks(f(g(h())))`.
func (c *IntegrationConfigClient) Use(hooks ...Hook) {
	c.hooks.IntegrationConfig = append(c.hooks.IntegrationConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `integrationconfig.Intercept(f(g(h())))`.
func (c *IntegrationConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.IntegrationConfig = append(c.inters.IntegrationConfig, interceptors...)
}

// Create returns a builder for creating a IntegrationConfig entity.
func (c *IntegrationConfigClient) Create() *IntegrationConfigCreate {
	mutation := newIntegrationConfigMutation(c.config, OpCreate)
	return &IntegrationConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IntegrationConfig entities.
func (c *IntegrationConfigClient) CreateBulk(builders ...*IntegrationConfigCreate) *IntegrationConfigCreateBulk {
	return &IntegrationConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IntegrationConfigClient) MapCreateBulk(slice any, setFunc func(*IntegrationConfigCreate, int)) *IntegrationConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IntegrationConfigCreateBulk{err: fmt.Errorf("calling to IntegrationConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IntegrationConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IntegrationConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IntegrationConfig.
func (c *IntegrationConfigClient) Update() *IntegrationConfigUpdate {
	mutation := newIntegrationConfigMutation(c.config, OpUpdate)
	return &IntegrationConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntegrationConfigClient) UpdateOne(_m *IntegrationConfig) *IntegrationConfigUpdateOne {
	mutation := newIntegrationConfigMutation(c.config, OpUpdateOne, withIntegrationConfig(_m))
	return &IntegrationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntegrationConfigClient) UpdateOneID(id uuid.UUID) *IntegrationConfigUpdateOne {
	mutation := newIntegrationConfigMutation(c.config, OpUpdateOne, withIntegrationConfigID(id))
	return &IntegrationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IntegrationConfig.
func (c *IntegrationConfigClient) Delete() *IntegrationConfigDelete {
	mutation := newIntegrationConfigMutation(c.config, OpDelete)
	return &IntegrationConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntegrationConfigClient) DeleteOne(_m *IntegrationConfig) *IntegrationConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntegrationConfigClient) DeleteOneID(id uuid.UUID) *IntegrationConfigDeleteOne {
	builder := c.Delete().Where(integrationconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntegrationConfigDeleteOne{builder}
}

// Query returns a query builder for IntegrationConfig.
func (c *IntegrationConfigClient) Query() *IntegrationConfigQuery {
	return &IntegrationConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIntegrationConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a IntegrationConfig entity by its id.
func (c *IntegrationConfigClient) Get(ctx context.Context, id uuid.UUID) (*IntegrationConfig, error) {
	return c.Query().Where(integrationconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntegrationConfigClient) GetX(ctx context.Context, id uuid.UUID) *IntegrationConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IntegrationConfigClient) Hooks() []Hook {
	return c.hooks.IntegrationConfig
}

// Interceptors returns the client interceptors.
func (c *IntegrationConfigClient) Interceptors() []Interceptor {
	return c.inters.IntegrationConfig
}

func (c *IntegrationConfigClient) mutate(ctx context.Context, m *IntegrationConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntegrationConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntegrationConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntegrationConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntegrationConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IntegrationConfig mutation op: %q", m.Op())
	}
}

// LoginAttemptClient is a client for the LoginAttempt schema.
type LoginAttemptClient struct {
	config
}

// NewLoginAttemptClient returns a client for the LoginAttempt from the given config.
func NewLoginAttemptClient(c config) *LoginAttemptClient {
	return &LoginAttemptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `loginattempt.Hooks(f(g(h())))`.
func (c *LoginAttemptClient) Use(hooks ...Hook) {
	c.hooks.LoginAttempt = append(c.hooks.LoginAttempt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `loginattempt.Intercept(f(g(h())))`.
func (c *LoginAttemptClient) Intercept(interceptors ...Interceptor) {
	c.inters.LoginAttempt = append(c.inters.LoginAttempt, interceptors...)
}

// Create returns a builder for creating a LoginAttempt entity.
func (c *LoginAttemptClient) Create() *LoginAttemptCreate {
	mutation := newLoginAttemptMutation(c.config, OpCreate)
	return &LoginAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LoginAttempt entities.
func (c *LoginAttemptClient) CreateBulk(builders ...*LoginAttemptCreate) *LoginAttemptCreateBulk {
	return &LoginAttemptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LoginAttemptClient) MapCreateBulk(slice any, setFunc func(*LoginAttemptCreate, int)) *LoginAttemptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LoginAttemptCreateBulk{err: fmt.Errorf("calling to LoginAttemptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LoginAttemptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LoginAttemptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LoginAttempt.
func (c *LoginAttemptClient) Update() *LoginAttemptUpdate {
	mutation := newLoginAttemptMutation(c.config, OpUpdate)
	return &LoginAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LoginAttemptClient) UpdateOne(_m *LoginAttempt) *LoginAttemptUpdateOne {
	mutation := newLoginAttemptMutation(c.config, OpUpdateOne, withLoginAttempt(_m))
	return &LoginAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LoginAttemptClient) UpdateOneID(id uuid.UUID) *LoginAttemptUpdateOne {
	mutation := newLoginAttemptMutation(c.config, OpUpdateOne, withLoginAttemptID(id))
	return &LoginAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LoginAttempt.
func (c *LoginAttemptClient) Delete() *LoginAttemptDelete {
	mutation := newLoginAttemptMutation(c.config, OpDelete)
	return &LoginAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LoginAttemptClient) DeleteOne(_m *LoginAttempt) *LoginAttemptDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LoginAttemptClient) DeleteOneID(id uuid.UUID) *LoginAttemptDeleteOne {
	builder := c.Delete().Where(loginattempt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LoginAttemptDeleteOne{builder}
}

// Query returns a query builder for LoginAttempt.
func (c *LoginAttemptClient) Query() *LoginAttemptQuery {
	return &LoginAttemptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLoginAttempt},
		inters: c.Interceptors(),
	}
}

// Get returns a LoginAttempt entity by its id.
func (c *LoginAttemptClient) Get(ctx context.Context, id uuid.UUID) (*LoginAttempt, error) {
	return c.Query().Where(loginattempt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LoginAttemptClient) GetX(ctx context.Context, id uuid.UUID) *LoginAttempt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LoginAttemptClient) Hooks() []Hook {
	return c.hooks.LoginAttempt
}

// Interceptors returns the client interceptors.
func (c *LoginAttemptClient) Interceptors() []Interceptor {
	return c.inters.LoginAttempt
}

func (c *LoginAttemptClient) mutate(ctx context.Context, m *LoginAttemptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LoginAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LoginAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LoginAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LoginAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LoginAttempt mutation op: %q", m.Op())
	}
}

// MFABackupCodeClient is a client for the MFABackupCode schema.
type MFABackupCodeClient struct {
	config
}

// NewMFABackupCodeClient returns a client for the MFABackupCode from the given config.
func NewMFABackupCodeClient(c config) *MFABackupCodeClient {
	return &MFABackupCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mfabackupcode.Hooks(f(g(h())))`.
func (c *MFABackupCodeClient) Use(hooks ...Hook) {
	c.hooks.MFABackupCode = append(c.hooks.MFABackupCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mfabackupcode.Intercept(f(g(h())))`.
func (c *MFABackupCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.MFABackupCode = append(c.inters.MFABackupCode, interceptors...)
}

// Create returns a builder for creating a MFABackupCode entity.
func (c *MFABackupCodeClient) Create() *MFABackupCodeCreate {
	mutation := newMFABackupCodeMutation(c.config, OpCreate)
	return &MFABackupCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MFABackupCode entities.
func (c *MFABackupCodeClient) CreateBulk(builders ...*MFABackupCodeCreate) *MFABackupCodeCreateBulk {
	return &MFABackupCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MFABackupCodeClient) MapCreateBulk(slice any, setFunc func(*MFABackupCodeCreate, int)) *MFABackupCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MFABackupCodeCreateBulk{err: fmt.Errorf("calling to MFABackupCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MFABackupCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MFABackupCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MFABackupCode.
func (c *MFABackupCodeClient) Update() *MFABackupCodeUpdate {
	mutation := newMFABackupCodeMutation(c.config, OpUpdate)
	return &MFABackupCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MFABackupCodeClient) UpdateOne(_m *MFABackupCode) *MFABackupCodeUpdateOne {
	mutation := newMFABackupCodeMutation(c.config, OpUpdateOne, withMFABackupCode(_m))
	return &MFABackupCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MFABackupCodeClient) UpdateOneID(id uuid.UUID) *MFABackupCodeUpdateOne {
	mutation := newMFABackupCodeMutation(c.config, OpUpdateOne, withMFABackupCodeID(id))
	return &MFABackupCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MFABackupCode.
func (c *MFABackupCodeClient) Delete() *MFABackupCodeDelete {
	mutation := newMFABackupCodeMutation(c.config, OpDelete)
	return &MFABackupCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MFABackupCodeClient) DeleteOne(_m *MFABackupCode) *MFABackupCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MFABackupCodeClient) DeleteOneID(id uuid.UUID) *MFABackupCodeDeleteOne {
	builder := c.Delete().Where(mfabackupcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MFABackupCodeDeleteOne{builder}
}

// Query returns a query builder for MFABackupCode.
func (c *MFABackupCodeClient) Query() *MFABackupCodeQuery {
	return &MFABackupCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMFABackupCode},
		inters: c.Interceptors(),
	}
}

// Get returns a MFABackupCode entity by its id.
func (c *MFABackupCodeClient) Get(ctx context.Context, id uuid.UUID) (*MFABackupCode, error) {
	return c.Query().Where(mfabackupcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MFABackupCodeClient) GetX(ctx context.Context, id uuid.UUID) *MFABackupCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MFABackupCode.
func (c *MFABackupCodeClient) QueryUser(_m *MFABackupCode) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mfabackupcode.Table, mfabackupcode.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mfabackupcode.UserTable, mfabackupcode.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MFABackupCodeClient) Hooks() []Hook {
	return c.hooks.MFABackupCode
}

// Interceptors returns the client interceptors.
func (c *MFABackupCodeClient) Interceptors() []Interceptor {
	return c.inters.MFABackupCode
}

func (c *MFABackupCodeClient) mutate(ctx context.Context, m *MFABackupCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MFABackupCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MFABackupCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MFABackupCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MFABackupCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MFABackupCode mutation op: %q", m.Op())
	}
}

// MFASettingsClient is a client for the MFASettings schema.
type MFASettingsClient struct {
	config
}

// NewMFASettingsClient returns a client for the MFASettings from the given config.
func NewMFASettingsClient(c config) *MFASettingsClient {
	return &MFASettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mfasettings.Hooks(f(g(h())))`.
func (c *MFASettingsClient) Use(hooks ...Hook) {
	c.hooks.MFASettings = append(c.hooks.MFASettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mfasettings.Intercept(f(g(h())))`.
func (c *MFASettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MFASettings = append(c.inters.MFASettings, interceptors...)
}

// Create returns a builder for creating a MFASettings entity.
func (c *MFASettingsClient) Create() *MFASettingsCreate {
	mutation := newMFASettingsMutation(c.config, OpCreate)
	return &MFASettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MFASettings entities.
func (c *MFASettingsClient) CreateBulk(builders ...*MFASettingsCreate) *MFASettingsCreateBulk {
	return &MFASettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MFASettingsClient) MapCreateBulk(slice any, setFunc func(*MFASettingsCreate, int)) *MFASettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MFASettingsCreateBulk{err: fmt.Errorf("calling to MFASettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MFASettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MFASettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MFASettings.
func (c *MFASettingsClient) Update() *MFASettingsUpdate {
	mutation := newMFASettingsMutation(c.config, OpUpdate)
	return &MFASettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MFASettingsClient) UpdateOne(_m *MFASettings) *MFASettingsUpdateOne {
	mutation := newMFASettingsMutation(c.config, OpUpdateOne, withMFASettings(_m))
	return &MFASettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MFASettingsClient) UpdateOneID(id int) *MFASettingsUpdateOne {
	mutation := newMFASettingsMutation(c.config, OpUpdateOne, withMFASettingsID(id))
	return &MFASettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MFASettings.
func (c *MFASettingsClient) Delete() *MFASettingsDelete {
	mutation := newMFASettingsMutation(c.config, OpDelete)
	return &MFASettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MFASettingsClient) DeleteOne(_m *MFASettings) *MFASettingsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MFASettingsClient) DeleteOneID(id int) *MFASettingsDeleteOne {
	builder := c.Delete().Where(mfasettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MFASettingsDeleteOne{builder}
}

// Query returns a query builder for MFASettings.
func (c *MFASettingsClient) Query() *MFASettingsQuery {
	return &MFASettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMFASettings},
		inters: c.Interceptors(),
	}
}

// Get returns a MFASettings entity by its id.
func (c *MFASettingsClient) Get(ctx context.Context, id int) (*MFASettings, error) {
	return c.Query().Where(mfasettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MFASettingsClient) GetX(ctx context.Context, id int) *MFASettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MFASettingsClient) Hooks() []Hook {
	return c.hooks.MFASettings
}

// Interceptors returns the client interceptors.
func (c *MFASettingsClient) Interceptors() []Interceptor {
	return c.inters.MFASettings
}

func (c *MFASettingsClient) mutate(ctx context.Context, m *MFASettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MFASettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MFASettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MFASettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MFASettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MFASettings mutation op: %q", m.Op())
	}
}

// MFATOTPSecretClient is a client for the MFATOTPSecret schema.
type MFATOTPSecretClient struct {
	config
}

// NewMFATOTPSecretClient returns a client for the MFATOTPSecret from the given config.
func NewMFATOTPSecretClient(c config) *MFATOTPSecretClient {
	return &MFATOTPSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mfatotpsecret.Hooks(f(g(h())))`.
func (c *MFATOTPSecretClient) Use(hooks ...Hook) {
	c.hooks.MFATOTPSecret = append(c.hooks.MFATOTPSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mfatotpsecret.Intercept(f(g(h())))`.
func (c *MFATOTPSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.MFATOTPSecret = append(c.inters.MFATOTPSecret, interceptors...)
}

// Create returns a builder for creating a MFATOTPSecret entity.
func (c *MFATOTPSecretClient) Create() *MFATOTPSecretCreate {
	mutation := newMFATOTPSecretMutation(c.config, OpCreate)
	return &MFATOTPSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MFATOTPSecret entities.
func (c *MFATOTPSecretClient) CreateBulk(builders ...*MFATOTPSecretCreate) *MFATOTPSecretCreateBulk {
	return &MFATOTPSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MFATOTPSecretClient) MapCreateBulk(slice any, setFunc func(*MFATOTPSecretCreate, int)) *MFATOTPSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MFATOTPSecretCreateBulk{err: fmt.Errorf("calling to MFATOTPSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MFATOTPSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MFATOTPSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MFATOTPSecret.
func (c *MFATOTPSecretClient) Update() *MFATOTPSecretUpdate {
	mutation := newMFATOTPSecretMutation(c.config, OpUpdate)
	return &MFATOTPSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MFATOTPSecretClient) UpdateOne(_m *MFATOTPSecret) *MFATOTPSecretUpdateOne {
	mutation := newMFATOTPSecretMutation(c.config, OpUpdateOne, withMFATOTPSecret(_m))
	return &MFATOTPSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MFATOTPSecretClient) UpdateOneID(id uuid.UUID) *MFATOTPSecretUpdateOne {
	mutation := newMFATOTPSecretMutation(c.config, OpUpdateOne, withMFATOTPSecretID(id))
	return &MFATOTPSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MFATOTPSecret.
func (c *MFATOTPSecretClient) Delete() *MFATOTPSecretDelete {
	mutation := newMFATOTPSecretMutation(c.config, OpDelete)
	return &MFATOTPSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MFATOTPSecretClient) DeleteOne(_m *MFATOTPSecret) *MFATOTPSecretDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MFATOTPSecretClient) DeleteOneID(id uuid.UUID) *MFATOTPSecretDeleteOne {
	builder := c.Delete().Where(mfatotpsecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MFATOTPSecretDeleteOne{builder}
}

// Query returns a query builder for MFATOTPSecret.
func (c *MFATOTPSecretClient) Query() *MFATOTPSecretQuery {
	return &MFATOTPSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMFATOTPSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a MFATOTPSecret entity by its id.
func (c *MFATOTPSecretClient) Get(ctx context.Context, id uuid.UUID) (*MFATOTPSecret, error) {
	return c.Query().Where(mfatotpsecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MFATOTPSecretClient) GetX(ctx context.Context, id uuid.UUID) *MFATOTPSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MFATOTPSecret.
func (c *MFATOTPSecretClient) QueryUser(_m *MFATOTPSecret) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mfatotpsecret.Table, mfatotpsecret.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mfatotpsecret.UserTable, mfatotpsecret.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MFATOTPSecretClient) Hooks() []Hook {
	return c.hooks.MFATOTPSecret
}

// Interceptors returns the client interceptors.
func (c *MFATOTPSecretClient) Interceptors() []Interceptor {
	return c.inters.MFATOTPSecret
}

func (c *MFATOTPSecretClient) mutate(ctx context.Context, m *MFATOTPSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MFATOTPSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MFATOTPSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MFATOTPSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MFATOTPSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MFATOTPSecret mutation op: %q", m.Op())
	}
}

// OAuthClientClient is a client for the OAuthClient schema.
type OAuthClientClient struct {
	config
}

// NewOAuthClientClient returns a client for the OAuthClient from the given config.
func NewOAuthClientClient(c config) *OAuthClientClient {
	return &OAuthClientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthclient.Hooks(f(g(h())))`.
func (c *OAuthClientClient) Use(hooks ...Hook) {
	c.hooks.OAuthClient = append(c.hooks.OAuthClient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthclient.Intercept(f(g(h())))`.
func (c *OAuthClientClient) Intercept(interceptors ...Interceptor) {
	c.inters.OAuthClient = append(c.inters.OAuthClient, interceptors...)
}

// Create returns a builder for creating a OAuthClient entity.
func (c *OAuthClientClient) Create() *OAuthClientCreate {
	mutation := newOAuthClientMutation(c.config, OpCreate)
	return &OAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OAuthClient entities.
func (c *OAuthClientClient) CreateBulk(builders ...*OAuthClientCreate) *OAuthClientCreateBulk {
	return &OAuthClientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OAuthClientClient) MapCreateBulk(slice any, setFunc func(*OAuthClientCreate, int)) *OAuthClientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OAuthClientCreateBulk{err: fmt.Errorf("calling to OAuthClientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OAuthClientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OAuthClientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OAuthClient.
func (c *OAuthClientClient) Update() *OAuthClientUpdate {
	mutation := newOAuthClientMutation(c.config, OpUpdate)
	return &OAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OAuthClientClient) UpdateOne(_m *OAuthClient) *OAuthClientUpdateOne {
	mutation := newOAuthClientMutation(c.config, OpUpdateOne, withOAuthClient(_m))
	return &OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OAuthClientClient) UpdateOneID(id uuid.UUID) *OAuthClientUpdateOne {
	mutation := newOAuthClientMutation(c.config, OpUpdateOne, withOAuthClientID(id))
	return &OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OAuthClient.
func (c *OAuthClientClient) Delete() *OAuthClientDelete {
	mutation := newOAuthClientMutation(c.config, OpDelete)
	return &OAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OAuthClientClient) DeleteOne(_m *OAuthClient) *OAuthClientDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OAuthClientClient) DeleteOneID(id uuid.UUID) *OAuthClientDeleteOne {
	builder := c.Delete().Where(oauthclient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OAuthClientDeleteOne{builder}
}

// Query returns a query builder for OAuthClient.
func (c *OAuthClientClient) Query() *OAuthClientQuery {
	return &OAuthClientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOAuthClient},
		inters: c.Interceptors(),
	}
}

// Get returns a OAuthClient entity by its id.
func (c *OAuthClientClient) Get(ctx context.Context, id uuid.UUID) (*OAuthClient, error) {
	return c.Query().Where(oauthclient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OAuthClientClient) GetX(ctx context.Context, id uuid.UUID) *OAuthClient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OAuthClientClient) Hooks() []Hook {
	return c.hooks.OAuthClient
}

// Interceptors returns the client interceptors.
func (c *OAuthClientClient) Interceptors() []Interceptor {
	return c.inters.OAuthClient
}

func (c *OAuthClientClient) mutate(ctx context.Context, m *OAuthClientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OAuthClient mutation op: %q", m.Op())
	}
}

// PasswordResetTokenClient is a client for the PasswordResetToken schema.
type PasswordResetTokenClient struct {
	config
}

// NewPasswordResetTokenClient returns a client for the PasswordResetToken from the given config.
func NewPasswordResetTokenClient(c config) *PasswordResetTokenClient {
	return &PasswordResetTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordresettoken.Hooks(f(g(h())))`.
func (c *PasswordResetTokenClient) Use(hooks ...Hook) {
	c.hooks.PasswordResetToken = append(c.hooks.PasswordResetToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordresettoken.Intercept(f(g(h())))`.
func (c *PasswordResetTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordResetToken = append(c.inters.PasswordResetToken, interceptors...)
}

// Create returns a builder for creating a PasswordResetToken entity.
func (c *PasswordResetTokenClient) Create() *PasswordResetTokenCreate {
	mutation := newPasswordResetTokenMutation(c.config, OpCreate)
	return &PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordResetToken entities.
func (c *PasswordResetTokenClient) CreateBulk(builders ...*PasswordResetTokenCreate) *PasswordResetTokenCreateBulk {
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordResetTokenClient) MapCreateBulk(slice any, setFunc func(*PasswordResetTokenCreate, int)) *PasswordResetTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordResetTokenCreateBulk{err: fmt.Errorf("calling to PasswordResetTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordResetTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordResetTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Update() *PasswordResetTokenUpdate {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdate)
	return &PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordResetTokenClient) UpdateOne(_m *PasswordResetToken) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetToken(_m))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordResetTokenClient) UpdateOneID(id uuid.UUID) *PasswordResetTokenUpdateOne {
	mutation := newPasswordResetTokenMutation(c.config, OpUpdateOne, withPasswordResetTokenID(id))
	return &PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Delete() *PasswordResetTokenDelete {
	mutation := newPasswordResetTokenMutation(c.config, OpDelete)
	return &PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordResetTokenClient) DeleteOne(_m *PasswordResetToken) *PasswordResetTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordResetTokenClient) DeleteOneID(id uuid.UUID) *PasswordResetTokenDeleteOne {
	builder := c.Delete().Where(passwordresettoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordResetTokenDeleteOne{builder}
}

// Query returns a query builder for PasswordResetToken.
func (c *PasswordResetTokenClient) Query() *PasswordResetTokenQuery {
	return &PasswordResetTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordResetToken},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordResetToken entity by its id.
func (c *PasswordResetTokenClient) Get(ctx context.Context, id uuid.UUID) (*PasswordResetToken, error) {
	return c.Query().Where(passwordresettoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordResetTokenClient) GetX(ctx context.Context, id uuid.UUID) *PasswordResetToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PasswordResetToken.
func (c *PasswordResetTokenClient) QueryUser(_m *PasswordResetToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordresettoken.Table, passwordresettoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passwordresettoken.UserTable, passwordresettoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordResetTokenClient) Hooks() []Hook {
	return c.hooks.PasswordResetToken
}

// Interceptors returns the client interceptors.
func (c *PasswordResetTokenClient) Interceptors() []Interceptor {
	return c.inters.PasswordResetToken
}

func (c *PasswordResetTokenClient) mutate(ctx context.Context, m *PasswordResetTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordResetTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordResetTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordResetTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordResetTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PasswordResetToken mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(_m *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(_m))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(_m *Session) *SessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(_m *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// TenantClient is a client for the Tenant schema.
type TenantClient struct {
	config
}

// NewTenantClient returns a client for the Tenant from the given config.
func NewTenantClient(c config) *TenantClient {
	return &TenantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenant.Hooks(f(g(h())))`.
func (c *TenantClient) Use(hooks ...Hook) {
	c.hooks.Tenant = append(c.hooks.Tenant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenant.Intercept(f(g(h())))`.
func (c *TenantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tenant = append(c.inters.Tenant, interceptors...)
}

// Create returns a builder for creating a Tenant entity.
func (c *TenantClient) Create() *TenantCreate {
	mutation := newTenantMutation(c.config, OpCreate)
	return &TenantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenant entities.
func (c *TenantClient) CreateBulk(builders ...*TenantCreate) *TenantCreateBulk {
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantClient) MapCreateBulk(slice any, setFunc func(*TenantCreate, int)) *TenantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantCreateBulk{err: fmt.Errorf("calling to TenantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenant.
func (c *TenantClient) Update() *TenantUpdate {
	mutation := newTenantMutation(c.config, OpUpdate)
	return &TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantClient) UpdateOne(_m *Tenant) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenant(_m))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantClient) UpdateOneID(id uuid.UUID) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenantID(id))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenant.
func (c *TenantClient) Delete() *TenantDelete {
	mutation := newTenantMutation(c.config, OpDelete)
	return &TenantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantClient) DeleteOne(_m *Tenant) *TenantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantClient) DeleteOneID(id uuid.UUID) *TenantDeleteOne {
	builder := c.Delete().Where(tenant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantDeleteOne{builder}
}

// Query returns a query builder for Tenant.
func (c *TenantClient) Query() *TenantQuery {
	return &TenantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenant},
		inters: c.Interceptors(),
	}
}

// Get returns a Tenant entity by its id.
func (c *TenantClient) Get(ctx context.Context, id uuid.UUID) (*Tenant, error) {
	return c.Query().Where(tenant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantClient) GetX(ctx context.Context, id uuid.UUID) *Tenant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberships queries the memberships edge of a Tenant.
func (c *TenantClient) QueryMemberships(_m *Tenant) *TenantMembershipQuery {
	query := (&TenantMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(tenantmembership.Table, tenantmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.MembershipsTable, tenant.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenantClient) Hooks() []Hook {
	return c.hooks.Tenant
}

// Interceptors returns the client interceptors.
func (c *TenantClient) Interceptors() []Interceptor {
	return c.inters.Tenant
}

func (c *TenantClient) mutate(ctx context.Context, m *TenantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tenant mutation op: %q", m.Op())
	}
}

// TenantMembershipClient is a client for the TenantMembership schema.
type TenantMembershipClient struct {
	config
}

// NewTenantMembershipClient returns a client for the TenantMembership from the given config.
func NewTenantMembershipClient(c config) *TenantMembershipClient {
	return &TenantMembershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenantmembership.Hooks(f(g(h())))`.
func (c *TenantMembershipClient) Use(hooks ...Hook) {
	c.hooks.TenantMembership = append(c.hooks.TenantMembership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenantmembership.Intercept(f(g(h())))`.
func (c *TenantMembershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.TenantMembership = append(c.inters.TenantMembership, interceptors...)
}

// Create returns a builder for creating a TenantMembership entity.
func (c *TenantMembershipClient) Create() *TenantMembershipCreate {
	mutation := newTenantMembershipMutation(c.config, OpCreate)
	return &TenantMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TenantMembership entities.
func (c *TenantMembershipClient) CreateBulk(builders ...*TenantMembershipCreate) *TenantMembershipCreateBulk {
	return &TenantMembershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantMembershipClient) MapCreateBulk(slice any, setFunc func(*TenantMembershipCreate, int)) *TenantMembershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantMembershipCreateBulk{err: fmt.Errorf("calling to TenantMembershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantMembershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantMembershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TenantMembership.
func (c *TenantMembershipClient) Update() *TenantMembershipUpdate {
	mutation := newTenantMembershipMutation(c.config, OpUpdate)
	return &TenantMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantMembershipClient) UpdateOne(_m *TenantMembership) *TenantMembershipUpdateOne {
	mutation := newTenantMembershipMutation(c.config, OpUpdateOne, withTenantMembership(_m))
	return &TenantMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantMembershipClient) UpdateOneID(id uuid.UUID) *TenantMembershipUpdateOne {
	mutation := newTenantMembershipMutation(c.config, OpUpdateOne, withTenantMembershipID(id))
	return &TenantMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TenantMembership.
func (c *TenantMembershipClient) Delete() *TenantMembershipDelete {
	mutation := newTenantMembershipMutation(c.config, OpDelete)
	return &TenantMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantMembershipClient) DeleteOne(_m *TenantMembership) *TenantMembershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantMembershipClient) DeleteOneID(id uuid.UUID) *TenantMembershipDeleteOne {
	builder := c.Delete().Where(tenantmembership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantMembershipDeleteOne{builder}
}

// Query returns a query builder for TenantMembership.
func (c *TenantMembershipClient) Query() *TenantMembershipQuery {
	return &TenantMembershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenantMembership},
		inters: c.Interceptors(),
	}
}

// Get returns a TenantMembership entity by its id.
func (c *TenantMembershipClient) Get(ctx context.Context, id uuid.UUID) (*TenantMembership, error) {
	return c.Query().Where(tenantmembership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantMembershipClient) GetX(ctx context.Context, id uuid.UUID) *TenantMembership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TenantMembership.
func (c *TenantMembershipClient) QueryUser(_m *TenantMembership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenantmembership.Table, tenantmembership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tenantmembership.UserTable, tenantmembership.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a TenantMembership.
func (c *TenantMembershipClient) QueryTenant(_m *TenantMembership) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenantmembership.Table, tenantmembership.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tenantmembership.TenantTable, tenantmembership.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenantMembershipClient) Hooks() []Hook {
	return c.hooks.TenantMembership
}

// Interceptors returns the client interceptors.
func (c *TenantMembershipClient) Interceptors() []Interceptor {
	return c.inters.TenantMembership
}

func (c *TenantMembershipClient) mutate(ctx context.Context, m *TenantMembershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantMembershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantMembershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantMembershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantMembershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TenantMembership mutation op: %q", m.Op())
	}
}

// UsageMetricClient is a client for the UsageMetric schema.
type UsageMetricClient struct {
	config
}

// NewUsageMetricClient returns a client for the UsageMetric from the given config.
func NewUsageMetricClient(c config) *UsageMetricClient {
	return &UsageMetricClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usagemetric.Hooks(f(g(h())))`.
func (c *UsageMetricClient) Use(hooks ...Hook) {
	c.hooks.UsageMetric = append(c.hooks.UsageMetric, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usagemetric.Intercept(f(g(h())))`.
func (c *UsageMetricClient) Intercept(interceptors ...Interceptor) {
	c.inters.UsageMetric = append(c.inters.UsageMetric, interceptors...)
}

// Create returns a builder for creating a UsageMetric entity.
func (c *UsageMetricClient) Create() *UsageMetricCreate {
	mutation := newUsageMetricMutation(c.config, OpCreate)
	return &UsageMetricCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UsageMetric entities.
func (c *UsageMetricClient) CreateBulk(builders ...*UsageMetricCreate) *UsageMetricCreateBulk {
	return &UsageMetricCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UsageMetricClient) MapCreateBulk(slice any, setFunc func(*UsageMetricCreate, int)) *UsageMetricCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UsageMetricCreateBulk{err: fmt.Errorf("calling to UsageMetricClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UsageMetricCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UsageMetricCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UsageMetric.
func (c *UsageMetricClient) Update() *UsageMetricUpdate {
	mutation := newUsageMetricMutation(c.config, OpUpdate)
	return &UsageMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsageMetricClient) UpdateOne(_m *UsageMetric) *UsageMetricUpdateOne {
	mutation := newUsageMetricMutation(c.config, OpUpdateOne, withUsageMetric(_m))
	return &UsageMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsageMetricClient) UpdateOneID(id uuid.UUID) *UsageMetricUpdateOne {
	mutation := newUsageMetricMutation(c.config, OpUpdateOne, withUsageMetricID(id))
	return &UsageMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UsageMetric.
func (c *UsageMetricClient) Delete() *UsageMetricDelete {
	mutation := newUsageMetricMutation(c.config, OpDelete)
	return &UsageMetricDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsageMetricClient) DeleteOne(_m *UsageMetric) *UsageMetricDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsageMetricClient) DeleteOneID(id uuid.UUID) *UsageMetricDeleteOne {
	builder := c.Delete().Where(usagemetric.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsageMetricDeleteOne{builder}
}

// Query returns a query builder for UsageMetric.
func (c *UsageMetricClient) Query() *UsageMetricQuery {
	return &UsageMetricQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsageMetric},
		inters: c.Interceptors(),
	}
}

// Get returns a UsageMetric entity by its id.
func (c *UsageMetricClient) Get(ctx context.Context, id uuid.UUID) (*UsageMetric, error) {
	return c.Query().Where(usagemetric.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsageMetricClient) GetX(ctx context.Context, id uuid.UUID) *UsageMetric {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UsageMetricClient) Hooks() []Hook {
	return c.hooks.UsageMetric
}

// Interceptors returns the client interceptors.
func (c *UsageMetricClient) Interceptors() []Interceptor {
	return c.inters.UsageMetric
}

func (c *UsageMetricClient) mutate(ctx context.Context, m *UsageMetricMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsageMetricCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsageMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsageMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsageMetricDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UsageMetric mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMemberships queries the memberships edge of a User.
func (c *UserClient) QueryMemberships(_m *User) *TenantMembershipQuery {
	query := (&TenantMembershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tenantmembership.Table, tenantmembership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MembershipsTable, user.MembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswordResetTokens queries the password_reset_tokens edge of a User.
func (c *UserClient) QueryPasswordResetTokens(_m *User) *PasswordResetTokenQuery {
	query := (&PasswordResetTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordresettoken.Table, passwordresettoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordResetTokensTable, user.PasswordResetTokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIdentities queries the identities edge of a User.
func (c *UserClient) QueryIdentities(_m *User) *UserIdentityQuery {
	query := (&UserIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(useridentity.Table, useridentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IdentitiesTable, user.IdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthorizationCodes queries the authorization_codes edge of a User.
func (c *UserClient) QueryAuthorizationCodes(_m *User) *AuthorizationCodeQuery {
	query := (&AuthorizationCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(authorizationcode.Table, authorizationcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuthorizationCodesTable, user.AuthorizationCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMfaTotp queries the mfa_totp edge of a User.
func (c *UserClient) QueryMfaTotp(_m *User) *MFATOTPSecretQuery {
	query := (&MFATOTPSecretClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mfatotpsecret.Table, mfatotpsecret.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MfaTotpTable, user.MfaTotpColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMfaBackupCodes queries the mfa_backup_codes edge of a User.
func (c *UserClient) QueryMfaBackupCodes(_m *User) *MFABackupCodeQuery {
	query := (&MFABackupCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mfabackupcode.Table, mfabackupcode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MfaBackupCodesTable, user.MfaBackupCodesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserIdentityClient is a client for the UserIdentity schema.
type UserIdentityClient struct {
	config
}

// NewUserIdentityClient returns a client for the UserIdentity from the given config.
func NewUserIdentityClient(c config) *UserIdentityClient {
	return &UserIdentityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `useridentity.Hooks(f(g(h())))`.
func (c *UserIdentityClient) Use(hooks ...Hook) {
	c.hooks.UserIdentity = append(c.hooks.UserIdentity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `useridentity.Intercept(f(g(h())))`.
func (c *UserIdentityClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserIdentity = append(c.inters.UserIdentity, interceptors...)
}

// Create returns a builder for creating a UserIdentity entity.
func (c *UserIdentityClient) Create() *UserIdentityCreate {
	mutation := newUserIdentityMutation(c.config, OpCreate)
	return &UserIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserIdentity entities.
func (c *UserIdentityClient) CreateBulk(builders ...*UserIdentityCreate) *UserIdentityCreateBulk {
	return &UserIdentityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserIdentityClient) MapCreateBulk(slice any, setFunc func(*UserIdentityCreate, int)) *UserIdentityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserIdentityCreateBulk{err: fmt.Errorf("calling to UserIdentityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserIdentityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserIdentityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserIdentity.
func (c *UserIdentityClient) Update() *UserIdentityUpdate {
	mutation := newUserIdentityMutation(c.config, OpUpdate)
	return &UserIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserIdentityClient) UpdateOne(_m *UserIdentity) *UserIdentityUpdateOne {
	mutation := newUserIdentityMutation(c.config, OpUpdateOne, withUserIdentity(_m))
	return &UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserIdentityClient) UpdateOneID(id uuid.UUID) *UserIdentityUpdateOne {
	mutation := newUserIdentityMutation(c.config, OpUpdateOne, withUserIdentityID(id))
	return &UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserIdentity.
func (c *UserIdentityClient) Delete() *UserIdentityDelete {
	mutation := newUserIdentityMutation(c.config, OpDelete)
	return &UserIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserIdentityClient) DeleteOne(_m *UserIdentity) *UserIdentityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserIdentityClient) DeleteOneID(id uuid.UUID) *UserIdentityDeleteOne {
	builder := c.Delete().Where(useridentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserIdentityDeleteOne{builder}
}

// Query returns a query builder for UserIdentity.
func (c *UserIdentityClient) Query() *UserIdentityQuery {
	return &UserIdentityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserIdentity},
		inters: c.Interceptors(),
	}
}

// Get returns a UserIdentity entity by its id.
func (c *UserIdentityClient) Get(ctx context.Context, id uuid.UUID) (*UserIdentity, error) {
	return c.Query().Where(useridentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserIdentityClient) GetX(ctx context.Context, id uuid.UUID) *UserIdentity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserIdentity.
func (c *UserIdentityClient) QueryUser(_m *UserIdentity) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(useridentity.Table, useridentity.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, useridentity.UserTable, useridentity.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserIdentityClient) Hooks() []Hook {
	return c.hooks.UserIdentity
}

// Interceptors returns the client interceptors.
func (c *UserIdentityClient) Interceptors() []Interceptor {
	return c.inters.UserIdentity
}

func (c *UserIdentityClient) mutate(ctx context.Context, m *UserIdentityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserIdentity mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuditLog, AuthorizationCode, ConsentSession, FeatureEntitlement,
		IntegrationConfig, LoginAttempt, MFABackupCode, MFASettings, MFATOTPSecret,
		OAuthClient, PasswordResetToken, Session, Tenant, TenantMembership,
		UsageMetric, User, UserIdentity []ent.Hook
	}
	inters struct {
		AuditLog, AuthorizationCode, ConsentSession, FeatureEntitlement,
		IntegrationConfig, LoginAttempt, MFABackupCode, MFASettings, MFATOTPSecret,
		OAuthClient, PasswordResetToken, Session, Tenant, TenantMembership,
		UsageMetric, User, UserIdentity []ent.Interceptor
	}
)
