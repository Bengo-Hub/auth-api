// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/bengobox/auth-service/internal/ent/auditlog"
	"github.com/bengobox/auth-service/internal/ent/authorizationcode"
	"github.com/bengobox/auth-service/internal/ent/consentsession"
	"github.com/bengobox/auth-service/internal/ent/featureentitlement"
	"github.com/bengobox/auth-service/internal/ent/integrationconfig"
	"github.com/bengobox/auth-service/internal/ent/loginattempt"
	"github.com/bengobox/auth-service/internal/ent/mfabackupcode"
	"github.com/bengobox/auth-service/internal/ent/mfasettings"
	"github.com/bengobox/auth-service/internal/ent/mfatotpsecret"
	"github.com/bengobox/auth-service/internal/ent/oauthclient"
	"github.com/bengobox/auth-service/internal/ent/passwordresettoken"
	"github.com/bengobox/auth-service/internal/ent/predicate"
	"github.com/bengobox/auth-service/internal/ent/session"
	"github.com/bengobox/auth-service/internal/ent/tenant"
	"github.com/bengobox/auth-service/internal/ent/tenantmembership"
	"github.com/bengobox/auth-service/internal/ent/usagemetric"
	"github.com/bengobox/auth-service/internal/ent/user"
	"github.com/bengobox/auth-service/internal/ent/useridentity"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog           = "AuditLog"
	TypeAuthorizationCode  = "AuthorizationCode"
	TypeConsentSession     = "ConsentSession"
	TypeFeatureEntitlement = "FeatureEntitlement"
	TypeIntegrationConfig  = "IntegrationConfig"
	TypeLoginAttempt       = "LoginAttempt"
	TypeMFABackupCode      = "MFABackupCode"
	TypeMFASettings        = "MFASettings"
	TypeMFATOTPSecret      = "MFATOTPSecret"
	TypeOAuthClient        = "OAuthClient"
	TypePasswordResetToken = "PasswordResetToken"
	TypeSession            = "Session"
	TypeTenant             = "Tenant"
	TypeTenantMembership   = "TenantMembership"
	TypeUsageMetric        = "UsageMetric"
	TypeUser               = "User"
	TypeUserIdentity       = "UserIdentity"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	tenant_id     *uuid.UUID
	user_id       *uuid.UUID
	action        *string
	resource_type *string
	resource_id   *string
	ip_address    *string
	user_agent    *string
	context       *map[string]interface{}
	occurred_at   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uuid.UUID) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *AuditLogMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[auditlog.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, auditlog.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[auditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, auditlog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetContext sets the "context" field.
func (m *AuditLogMutation) SetContext(value map[string]interface{}) {
	m.context = &value
}

// Context returns the value of the "context" field in the mutation.
func (m *AuditLogMutation) Context() (r map[string]interface{}, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *AuditLogMutation) ClearContext() {
	m.context = nil
	m.clearedFields[auditlog.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *AuditLogMutation) ContextCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *AuditLogMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, auditlog.FieldContext)
}

// SetOccurredAt sets the "occurred_at" field.
func (m *AuditLogMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *AuditLogMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *AuditLogMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.context != nil {
		fields = append(fields, auditlog.FieldContext)
	}
	if m.occurred_at != nil {
		fields = append(fields, auditlog.FieldOccurredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldContext:
		return m.Context()
	case auditlog.FieldOccurredAt:
		return m.OccurredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldContext:
		return m.OldContext(ctx)
	case auditlog.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case auditlog.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldResourceType) {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldIPAddress) {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldContext) {
		fields = append(fields, auditlog.FieldContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldResourceType:
		m.ClearResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldContext:
		m.ClearContext()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldContext:
		m.ResetContext()
		return nil
	case auditlog.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// AuthorizationCodeMutation represents an operation that mutates the AuthorizationCode nodes in the graph.
type AuthorizationCodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	client_id             *string
	redirect_uri          *string
	scope                 *string
	code_hash             *string
	code_challenge        *string
	code_challenge_method *string
	nonce                 *string
	expires_at            *time.Time
	consumed_at           *time.Time
	metadata              *map[string]interface{}
	created_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*AuthorizationCode, error)
	predicates            []predicate.AuthorizationCode
}

var _ ent.Mutation = (*AuthorizationCodeMutation)(nil)

// authorizationcodeOption allows management of the mutation configuration using functional options.
type authorizationcodeOption func(*AuthorizationCodeMutation)

// newAuthorizationCodeMutation creates new mutation for the AuthorizationCode entity.
func newAuthorizationCodeMutation(c config, op Op, opts ...authorizationcodeOption) *AuthorizationCodeMutation {
	m := &AuthorizationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizationCodeID sets the ID field of the mutation.
func withAuthorizationCodeID(id uuid.UUID) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizationCode
		)
		m.oldValue = func(ctx context.Context) (*AuthorizationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizationCode sets the old AuthorizationCode of the mutation.
func withAuthorizationCode(node *AuthorizationCode) authorizationcodeOption {
	return func(m *AuthorizationCodeMutation) {
		m.oldValue = func(context.Context) (*AuthorizationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizationCode entities.
func (m *AuthorizationCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizationCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizationCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AuthorizationCodeMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthorizationCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthorizationCodeMutation) ResetUserID() {
	m.user = nil
}

// SetClientID sets the "client_id" field.
func (m *AuthorizationCodeMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuthorizationCodeMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuthorizationCodeMutation) ResetClientID() {
	m.client_id = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AuthorizationCodeMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AuthorizationCodeMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AuthorizationCodeMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScope sets the "scope" field.
func (m *AuthorizationCodeMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthorizationCodeMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthorizationCodeMutation) ResetScope() {
	m.scope = nil
}

// SetCodeHash sets the "code_hash" field.
func (m *AuthorizationCodeMutation) SetCodeHash(s string) {
	m.code_hash = &s
}

// CodeHash returns the value of the "code_hash" field in the mutation.
func (m *AuthorizationCodeMutation) CodeHash() (r string, exists bool) {
	v := m.code_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeHash returns the old "code_hash" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeHash: %w", err)
	}
	return oldValue.CodeHash, nil
}

// ResetCodeHash resets all changes to the "code_hash" field.
func (m *AuthorizationCodeMutation) ResetCodeHash() {
	m.code_hash = nil
}

// SetCodeChallenge sets the "code_challenge" field.
func (m *AuthorizationCodeMutation) SetCodeChallenge(s string) {
	m.code_challenge = &s
}

// CodeChallenge returns the value of the "code_challenge" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallenge() (r string, exists bool) {
	v := m.code_challenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallenge returns the old "code_challenge" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallenge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallenge: %w", err)
	}
	return oldValue.CodeChallenge, nil
}

// ResetCodeChallenge resets all changes to the "code_challenge" field.
func (m *AuthorizationCodeMutation) ResetCodeChallenge() {
	m.code_challenge = nil
}

// SetCodeChallengeMethod sets the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) SetCodeChallengeMethod(s string) {
	m.code_challenge_method = &s
}

// CodeChallengeMethod returns the value of the "code_challenge_method" field in the mutation.
func (m *AuthorizationCodeMutation) CodeChallengeMethod() (r string, exists bool) {
	v := m.code_challenge_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeChallengeMethod returns the old "code_challenge_method" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCodeChallengeMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeChallengeMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeChallengeMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeChallengeMethod: %w", err)
	}
	return oldValue.CodeChallengeMethod, nil
}

// ResetCodeChallengeMethod resets all changes to the "code_challenge_method" field.
func (m *AuthorizationCodeMutation) ResetCodeChallengeMethod() {
	m.code_challenge_method = nil
}

// SetNonce sets the "nonce" field.
func (m *AuthorizationCodeMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *AuthorizationCodeMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *AuthorizationCodeMutation) ResetNonce() {
	m.nonce = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthorizationCodeMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthorizationCodeMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthorizationCodeMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetConsumedAt sets the "consumed_at" field.
func (m *AuthorizationCodeMutation) SetConsumedAt(t time.Time) {
	m.consumed_at = &t
}

// ConsumedAt returns the value of the "consumed_at" field in the mutation.
func (m *AuthorizationCodeMutation) ConsumedAt() (r time.Time, exists bool) {
	v := m.consumed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumedAt returns the old "consumed_at" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldConsumedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumedAt: %w", err)
	}
	return oldValue.ConsumedAt, nil
}

// ClearConsumedAt clears the value of the "consumed_at" field.
func (m *AuthorizationCodeMutation) ClearConsumedAt() {
	m.consumed_at = nil
	m.clearedFields[authorizationcode.FieldConsumedAt] = struct{}{}
}

// ConsumedAtCleared returns if the "consumed_at" field was cleared in this mutation.
func (m *AuthorizationCodeMutation) ConsumedAtCleared() bool {
	_, ok := m.clearedFields[authorizationcode.FieldConsumedAt]
	return ok
}

// ResetConsumedAt resets all changes to the "consumed_at" field.
func (m *AuthorizationCodeMutation) ResetConsumedAt() {
	m.consumed_at = nil
	delete(m.clearedFields, authorizationcode.FieldConsumedAt)
}

// SetMetadata sets the "metadata" field.
func (m *AuthorizationCodeMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuthorizationCodeMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuthorizationCodeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[authorizationcode.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuthorizationCodeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[authorizationcode.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuthorizationCodeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, authorizationcode.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthorizationCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthorizationCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthorizationCode entity.
// If the AuthorizationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizationCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthorizationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthorizationCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[authorizationcode.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthorizationCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthorizationCodeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthorizationCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuthorizationCodeMutation builder.
func (m *AuthorizationCodeMutation) Where(ps ...predicate.AuthorizationCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizationCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizationCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizationCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizationCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizationCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizationCode).
func (m *AuthorizationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizationCodeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, authorizationcode.FieldUserID)
	}
	if m.client_id != nil {
		fields = append(fields, authorizationcode.FieldClientID)
	}
	if m.redirect_uri != nil {
		fields = append(fields, authorizationcode.FieldRedirectURI)
	}
	if m.scope != nil {
		fields = append(fields, authorizationcode.FieldScope)
	}
	if m.code_hash != nil {
		fields = append(fields, authorizationcode.FieldCodeHash)
	}
	if m.code_challenge != nil {
		fields = append(fields, authorizationcode.FieldCodeChallenge)
	}
	if m.code_challenge_method != nil {
		fields = append(fields, authorizationcode.FieldCodeChallengeMethod)
	}
	if m.nonce != nil {
		fields = append(fields, authorizationcode.FieldNonce)
	}
	if m.expires_at != nil {
		fields = append(fields, authorizationcode.FieldExpiresAt)
	}
	if m.consumed_at != nil {
		fields = append(fields, authorizationcode.FieldConsumedAt)
	}
	if m.metadata != nil {
		fields = append(fields, authorizationcode.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, authorizationcode.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizationcode.FieldUserID:
		return m.UserID()
	case authorizationcode.FieldClientID:
		return m.ClientID()
	case authorizationcode.FieldRedirectURI:
		return m.RedirectURI()
	case authorizationcode.FieldScope:
		return m.Scope()
	case authorizationcode.FieldCodeHash:
		return m.CodeHash()
	case authorizationcode.FieldCodeChallenge:
		return m.CodeChallenge()
	case authorizationcode.FieldCodeChallengeMethod:
		return m.CodeChallengeMethod()
	case authorizationcode.FieldNonce:
		return m.Nonce()
	case authorizationcode.FieldExpiresAt:
		return m.ExpiresAt()
	case authorizationcode.FieldConsumedAt:
		return m.ConsumedAt()
	case authorizationcode.FieldMetadata:
		return m.Metadata()
	case authorizationcode.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizationcode.FieldUserID:
		return m.OldUserID(ctx)
	case authorizationcode.FieldClientID:
		return m.OldClientID(ctx)
	case authorizationcode.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case authorizationcode.FieldScope:
		return m.OldScope(ctx)
	case authorizationcode.FieldCodeHash:
		return m.OldCodeHash(ctx)
	case authorizationcode.FieldCodeChallenge:
		return m.OldCodeChallenge(ctx)
	case authorizationcode.FieldCodeChallengeMethod:
		return m.OldCodeChallengeMethod(ctx)
	case authorizationcode.FieldNonce:
		return m.OldNonce(ctx)
	case authorizationcode.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case authorizationcode.FieldConsumedAt:
		return m.OldConsumedAt(ctx)
	case authorizationcode.FieldMetadata:
		return m.OldMetadata(ctx)
	case authorizationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizationcode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case authorizationcode.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case authorizationcode.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case authorizationcode.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case authorizationcode.FieldCodeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeHash(v)
		return nil
	case authorizationcode.FieldCodeChallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallenge(v)
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeChallengeMethod(v)
		return nil
	case authorizationcode.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case authorizationcode.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case authorizationcode.FieldConsumedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumedAt(v)
		return nil
	case authorizationcode.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case authorizationcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizationCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizationCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizationCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authorizationcode.FieldConsumedAt) {
		fields = append(fields, authorizationcode.FieldConsumedAt)
	}
	if m.FieldCleared(authorizationcode.FieldMetadata) {
		fields = append(fields, authorizationcode.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearField(name string) error {
	switch name {
	case authorizationcode.FieldConsumedAt:
		m.ClearConsumedAt()
		return nil
	case authorizationcode.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetField(name string) error {
	switch name {
	case authorizationcode.FieldUserID:
		m.ResetUserID()
		return nil
	case authorizationcode.FieldClientID:
		m.ResetClientID()
		return nil
	case authorizationcode.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case authorizationcode.FieldScope:
		m.ResetScope()
		return nil
	case authorizationcode.FieldCodeHash:
		m.ResetCodeHash()
		return nil
	case authorizationcode.FieldCodeChallenge:
		m.ResetCodeChallenge()
		return nil
	case authorizationcode.FieldCodeChallengeMethod:
		m.ResetCodeChallengeMethod()
		return nil
	case authorizationcode.FieldNonce:
		m.ResetNonce()
		return nil
	case authorizationcode.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case authorizationcode.FieldConsumedAt:
		m.ResetConsumedAt()
		return nil
	case authorizationcode.FieldMetadata:
		m.ResetMetadata()
		return nil
	case authorizationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, authorizationcode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizationCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorizationcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, authorizationcode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizationCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case authorizationcode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ClearEdge(name string) error {
	switch name {
	case authorizationcode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizationCodeMutation) ResetEdge(name string) error {
	switch name {
	case authorizationcode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AuthorizationCode edge %s", name)
}

// ConsentSessionMutation represents an operation that mutates the ConsentSession nodes in the graph.
type ConsentSessionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	user_id        *uuid.UUID
	client_id      *string
	granted_scopes *string
	granted_claims *map[string]interface{}
	expires_at     *time.Time
	last_used_at   *time.Time
	metadata       *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ConsentSession, error)
	predicates     []predicate.ConsentSession
}

var _ ent.Mutation = (*ConsentSessionMutation)(nil)

// consentsessionOption allows management of the mutation configuration using functional options.
type consentsessionOption func(*ConsentSessionMutation)

// newConsentSessionMutation creates new mutation for the ConsentSession entity.
func newConsentSessionMutation(c config, op Op, opts ...consentsessionOption) *ConsentSessionMutation {
	m := &ConsentSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeConsentSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsentSessionID sets the ID field of the mutation.
func withConsentSessionID(id uuid.UUID) consentsessionOption {
	return func(m *ConsentSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ConsentSession
		)
		m.oldValue = func(ctx context.Context) (*ConsentSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConsentSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsentSession sets the old ConsentSession of the mutation.
func withConsentSession(node *ConsentSession) consentsessionOption {
	return func(m *ConsentSessionMutation) {
		m.oldValue = func(context.Context) (*ConsentSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsentSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsentSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConsentSession entities.
func (m *ConsentSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsentSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsentSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConsentSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ConsentSessionMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConsentSessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConsentSessionMutation) ResetUserID() {
	m.user_id = nil
}

// SetClientID sets the "client_id" field.
func (m *ConsentSessionMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ConsentSessionMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ConsentSessionMutation) ResetClientID() {
	m.client_id = nil
}

// SetGrantedScopes sets the "granted_scopes" field.
func (m *ConsentSessionMutation) SetGrantedScopes(s string) {
	m.granted_scopes = &s
}

// GrantedScopes returns the value of the "granted_scopes" field in the mutation.
func (m *ConsentSessionMutation) GrantedScopes() (r string, exists bool) {
	v := m.granted_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedScopes returns the old "granted_scopes" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldGrantedScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedScopes: %w", err)
	}
	return oldValue.GrantedScopes, nil
}

// ResetGrantedScopes resets all changes to the "granted_scopes" field.
func (m *ConsentSessionMutation) ResetGrantedScopes() {
	m.granted_scopes = nil
}

// SetGrantedClaims sets the "granted_claims" field.
func (m *ConsentSessionMutation) SetGrantedClaims(value map[string]interface{}) {
	m.granted_claims = &value
}

// GrantedClaims returns the value of the "granted_claims" field in the mutation.
func (m *ConsentSessionMutation) GrantedClaims() (r map[string]interface{}, exists bool) {
	v := m.granted_claims
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedClaims returns the old "granted_claims" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldGrantedClaims(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedClaims is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedClaims requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedClaims: %w", err)
	}
	return oldValue.GrantedClaims, nil
}

// ClearGrantedClaims clears the value of the "granted_claims" field.
func (m *ConsentSessionMutation) ClearGrantedClaims() {
	m.granted_claims = nil
	m.clearedFields[consentsession.FieldGrantedClaims] = struct{}{}
}

// GrantedClaimsCleared returns if the "granted_claims" field was cleared in this mutation.
func (m *ConsentSessionMutation) GrantedClaimsCleared() bool {
	_, ok := m.clearedFields[consentsession.FieldGrantedClaims]
	return ok
}

// ResetGrantedClaims resets all changes to the "granted_claims" field.
func (m *ConsentSessionMutation) ResetGrantedClaims() {
	m.granted_claims = nil
	delete(m.clearedFields, consentsession.FieldGrantedClaims)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ConsentSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ConsentSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ConsentSessionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[consentsession.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ConsentSessionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[consentsession.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ConsentSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, consentsession.FieldExpiresAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *ConsentSessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *ConsentSessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *ConsentSessionMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[consentsession.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *ConsentSessionMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[consentsession.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *ConsentSessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, consentsession.FieldLastUsedAt)
}

// SetMetadata sets the "metadata" field.
func (m *ConsentSessionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ConsentSessionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ConsentSessionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[consentsession.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ConsentSessionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[consentsession.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ConsentSessionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, consentsession.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ConsentSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConsentSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConsentSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConsentSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConsentSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConsentSession entity.
// If the ConsentSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConsentSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConsentSessionMutation builder.
func (m *ConsentSessionMutation) Where(ps ...predicate.ConsentSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsentSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsentSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConsentSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsentSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsentSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConsentSession).
func (m *ConsentSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsentSessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_id != nil {
		fields = append(fields, consentsession.FieldUserID)
	}
	if m.client_id != nil {
		fields = append(fields, consentsession.FieldClientID)
	}
	if m.granted_scopes != nil {
		fields = append(fields, consentsession.FieldGrantedScopes)
	}
	if m.granted_claims != nil {
		fields = append(fields, consentsession.FieldGrantedClaims)
	}
	if m.expires_at != nil {
		fields = append(fields, consentsession.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, consentsession.FieldLastUsedAt)
	}
	if m.metadata != nil {
		fields = append(fields, consentsession.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, consentsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, consentsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsentSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consentsession.FieldUserID:
		return m.UserID()
	case consentsession.FieldClientID:
		return m.ClientID()
	case consentsession.FieldGrantedScopes:
		return m.GrantedScopes()
	case consentsession.FieldGrantedClaims:
		return m.GrantedClaims()
	case consentsession.FieldExpiresAt:
		return m.ExpiresAt()
	case consentsession.FieldLastUsedAt:
		return m.LastUsedAt()
	case consentsession.FieldMetadata:
		return m.Metadata()
	case consentsession.FieldCreatedAt:
		return m.CreatedAt()
	case consentsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsentSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consentsession.FieldUserID:
		return m.OldUserID(ctx)
	case consentsession.FieldClientID:
		return m.OldClientID(ctx)
	case consentsession.FieldGrantedScopes:
		return m.OldGrantedScopes(ctx)
	case consentsession.FieldGrantedClaims:
		return m.OldGrantedClaims(ctx)
	case consentsession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case consentsession.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case consentsession.FieldMetadata:
		return m.OldMetadata(ctx)
	case consentsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case consentsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConsentSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsentSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consentsession.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case consentsession.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case consentsession.FieldGrantedScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedScopes(v)
		return nil
	case consentsession.FieldGrantedClaims:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedClaims(v)
		return nil
	case consentsession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case consentsession.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case consentsession.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case consentsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case consentsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConsentSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsentSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsentSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsentSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConsentSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsentSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(consentsession.FieldGrantedClaims) {
		fields = append(fields, consentsession.FieldGrantedClaims)
	}
	if m.FieldCleared(consentsession.FieldExpiresAt) {
		fields = append(fields, consentsession.FieldExpiresAt)
	}
	if m.FieldCleared(consentsession.FieldLastUsedAt) {
		fields = append(fields, consentsession.FieldLastUsedAt)
	}
	if m.FieldCleared(consentsession.FieldMetadata) {
		fields = append(fields, consentsession.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsentSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsentSessionMutation) ClearField(name string) error {
	switch name {
	case consentsession.FieldGrantedClaims:
		m.ClearGrantedClaims()
		return nil
	case consentsession.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case consentsession.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case consentsession.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown ConsentSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsentSessionMutation) ResetField(name string) error {
	switch name {
	case consentsession.FieldUserID:
		m.ResetUserID()
		return nil
	case consentsession.FieldClientID:
		m.ResetClientID()
		return nil
	case consentsession.FieldGrantedScopes:
		m.ResetGrantedScopes()
		return nil
	case consentsession.FieldGrantedClaims:
		m.ResetGrantedClaims()
		return nil
	case consentsession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case consentsession.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case consentsession.FieldMetadata:
		m.ResetMetadata()
		return nil
	case consentsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case consentsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConsentSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsentSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsentSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsentSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsentSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsentSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsentSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsentSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConsentSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsentSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConsentSession edge %s", name)
}

// FeatureEntitlementMutation represents an operation that mutates the FeatureEntitlement nodes in the graph.
type FeatureEntitlementMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	tenant_id     *uuid.UUID
	feature_code  *string
	limit_json    *map[string]interface{}
	plan_source   *string
	synced_at     *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FeatureEntitlement, error)
	predicates    []predicate.FeatureEntitlement
}

var _ ent.Mutation = (*FeatureEntitlementMutation)(nil)

// featureentitlementOption allows management of the mutation configuration using functional options.
type featureentitlementOption func(*FeatureEntitlementMutation)

// newFeatureEntitlementMutation creates new mutation for the FeatureEntitlement entity.
func newFeatureEntitlementMutation(c config, op Op, opts ...featureentitlementOption) *FeatureEntitlementMutation {
	m := &FeatureEntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureEntitlementID sets the ID field of the mutation.
func withFeatureEntitlementID(id uuid.UUID) featureentitlementOption {
	return func(m *FeatureEntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureEntitlement
		)
		m.oldValue = func(ctx context.Context) (*FeatureEntitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureEntitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureEntitlement sets the old FeatureEntitlement of the mutation.
func withFeatureEntitlement(node *FeatureEntitlement) featureentitlementOption {
	return func(m *FeatureEntitlementMutation) {
		m.oldValue = func(context.Context) (*FeatureEntitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureEntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureEntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureEntitlement entities.
func (m *FeatureEntitlementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureEntitlementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureEntitlementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureEntitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *FeatureEntitlementMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FeatureEntitlementMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FeatureEntitlementMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetFeatureCode sets the "feature_code" field.
func (m *FeatureEntitlementMutation) SetFeatureCode(s string) {
	m.feature_code = &s
}

// FeatureCode returns the value of the "feature_code" field in the mutation.
func (m *FeatureEntitlementMutation) FeatureCode() (r string, exists bool) {
	v := m.feature_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureCode returns the old "feature_code" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldFeatureCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureCode: %w", err)
	}
	return oldValue.FeatureCode, nil
}

// ResetFeatureCode resets all changes to the "feature_code" field.
func (m *FeatureEntitlementMutation) ResetFeatureCode() {
	m.feature_code = nil
}

// SetLimitJSON sets the "limit_json" field.
func (m *FeatureEntitlementMutation) SetLimitJSON(value map[string]interface{}) {
	m.limit_json = &value
}

// LimitJSON returns the value of the "limit_json" field in the mutation.
func (m *FeatureEntitlementMutation) LimitJSON() (r map[string]interface{}, exists bool) {
	v := m.limit_json
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitJSON returns the old "limit_json" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldLimitJSON(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimitJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimitJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitJSON: %w", err)
	}
	return oldValue.LimitJSON, nil
}

// ClearLimitJSON clears the value of the "limit_json" field.
func (m *FeatureEntitlementMutation) ClearLimitJSON() {
	m.limit_json = nil
	m.clearedFields[featureentitlement.FieldLimitJSON] = struct{}{}
}

// LimitJSONCleared returns if the "limit_json" field was cleared in this mutation.
func (m *FeatureEntitlementMutation) LimitJSONCleared() bool {
	_, ok := m.clearedFields[featureentitlement.FieldLimitJSON]
	return ok
}

// ResetLimitJSON resets all changes to the "limit_json" field.
func (m *FeatureEntitlementMutation) ResetLimitJSON() {
	m.limit_json = nil
	delete(m.clearedFields, featureentitlement.FieldLimitJSON)
}

// SetPlanSource sets the "plan_source" field.
func (m *FeatureEntitlementMutation) SetPlanSource(s string) {
	m.plan_source = &s
}

// PlanSource returns the value of the "plan_source" field in the mutation.
func (m *FeatureEntitlementMutation) PlanSource() (r string, exists bool) {
	v := m.plan_source
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanSource returns the old "plan_source" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldPlanSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanSource: %w", err)
	}
	return oldValue.PlanSource, nil
}

// ResetPlanSource resets all changes to the "plan_source" field.
func (m *FeatureEntitlementMutation) ResetPlanSource() {
	m.plan_source = nil
}

// SetSyncedAt sets the "synced_at" field.
func (m *FeatureEntitlementMutation) SetSyncedAt(t time.Time) {
	m.synced_at = &t
}

// SyncedAt returns the value of the "synced_at" field in the mutation.
func (m *FeatureEntitlementMutation) SyncedAt() (r time.Time, exists bool) {
	v := m.synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncedAt returns the old "synced_at" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldSyncedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncedAt: %w", err)
	}
	return oldValue.SyncedAt, nil
}

// ClearSyncedAt clears the value of the "synced_at" field.
func (m *FeatureEntitlementMutation) ClearSyncedAt() {
	m.synced_at = nil
	m.clearedFields[featureentitlement.FieldSyncedAt] = struct{}{}
}

// SyncedAtCleared returns if the "synced_at" field was cleared in this mutation.
func (m *FeatureEntitlementMutation) SyncedAtCleared() bool {
	_, ok := m.clearedFields[featureentitlement.FieldSyncedAt]
	return ok
}

// ResetSyncedAt resets all changes to the "synced_at" field.
func (m *FeatureEntitlementMutation) ResetSyncedAt() {
	m.synced_at = nil
	delete(m.clearedFields, featureentitlement.FieldSyncedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureEntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureEntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureEntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureEntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureEntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureEntitlement entity.
// If the FeatureEntitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureEntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureEntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the FeatureEntitlementMutation builder.
func (m *FeatureEntitlementMutation) Where(ps ...predicate.FeatureEntitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureEntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureEntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureEntitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureEntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureEntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureEntitlement).
func (m *FeatureEntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureEntitlementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant_id != nil {
		fields = append(fields, featureentitlement.FieldTenantID)
	}
	if m.feature_code != nil {
		fields = append(fields, featureentitlement.FieldFeatureCode)
	}
	if m.limit_json != nil {
		fields = append(fields, featureentitlement.FieldLimitJSON)
	}
	if m.plan_source != nil {
		fields = append(fields, featureentitlement.FieldPlanSource)
	}
	if m.synced_at != nil {
		fields = append(fields, featureentitlement.FieldSyncedAt)
	}
	if m.created_at != nil {
		fields = append(fields, featureentitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featureentitlement.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureEntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureentitlement.FieldTenantID:
		return m.TenantID()
	case featureentitlement.FieldFeatureCode:
		return m.FeatureCode()
	case featureentitlement.FieldLimitJSON:
		return m.LimitJSON()
	case featureentitlement.FieldPlanSource:
		return m.PlanSource()
	case featureentitlement.FieldSyncedAt:
		return m.SyncedAt()
	case featureentitlement.FieldCreatedAt:
		return m.CreatedAt()
	case featureentitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureEntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureentitlement.FieldTenantID:
		return m.OldTenantID(ctx)
	case featureentitlement.FieldFeatureCode:
		return m.OldFeatureCode(ctx)
	case featureentitlement.FieldLimitJSON:
		return m.OldLimitJSON(ctx)
	case featureentitlement.FieldPlanSource:
		return m.OldPlanSource(ctx)
	case featureentitlement.FieldSyncedAt:
		return m.OldSyncedAt(ctx)
	case featureentitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featureentitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureEntitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureEntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureentitlement.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case featureentitlement.FieldFeatureCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureCode(v)
		return nil
	case featureentitlement.FieldLimitJSON:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitJSON(v)
		return nil
	case featureentitlement.FieldPlanSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanSource(v)
		return nil
	case featureentitlement.FieldSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncedAt(v)
		return nil
	case featureentitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featureentitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureEntitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureEntitlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureEntitlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureEntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureEntitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureEntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featureentitlement.FieldLimitJSON) {
		fields = append(fields, featureentitlement.FieldLimitJSON)
	}
	if m.FieldCleared(featureentitlement.FieldSyncedAt) {
		fields = append(fields, featureentitlement.FieldSyncedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureEntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureEntitlementMutation) ClearField(name string) error {
	switch name {
	case featureentitlement.FieldLimitJSON:
		m.ClearLimitJSON()
		return nil
	case featureentitlement.FieldSyncedAt:
		m.ClearSyncedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureEntitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureEntitlementMutation) ResetField(name string) error {
	switch name {
	case featureentitlement.FieldTenantID:
		m.ResetTenantID()
		return nil
	case featureentitlement.FieldFeatureCode:
		m.ResetFeatureCode()
		return nil
	case featureentitlement.FieldLimitJSON:
		m.ResetLimitJSON()
		return nil
	case featureentitlement.FieldPlanSource:
		m.ResetPlanSource()
		return nil
	case featureentitlement.FieldSyncedAt:
		m.ResetSyncedAt()
		return nil
	case featureentitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featureentitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureEntitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureEntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureEntitlementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureEntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureEntitlementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureEntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureEntitlementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureEntitlementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeatureEntitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureEntitlementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeatureEntitlement edge %s", name)
}

// IntegrationConfigMutation represents an operation that mutates the IntegrationConfig nodes in the graph.
type IntegrationConfigMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	tenant_id     *uuid.UUID
	service       *string
	config_data   *string
	key_id        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IntegrationConfig, error)
	predicates    []predicate.IntegrationConfig
}

var _ ent.Mutation = (*IntegrationConfigMutation)(nil)

// integrationconfigOption allows management of the mutation configuration using functional options.
type integrationconfigOption func(*IntegrationConfigMutation)

// newIntegrationConfigMutation creates new mutation for the IntegrationConfig entity.
func newIntegrationConfigMutation(c config, op Op, opts ...integrationconfigOption) *IntegrationConfigMutation {
	m := &IntegrationConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegrationConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationConfigID sets the ID field of the mutation.
func withIntegrationConfigID(id uuid.UUID) integrationconfigOption {
	return func(m *IntegrationConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *IntegrationConfig
		)
		m.oldValue = func(ctx context.Context) (*IntegrationConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IntegrationConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegrationConfig sets the old IntegrationConfig of the mutation.
func withIntegrationConfig(node *IntegrationConfig) integrationconfigOption {
	return func(m *IntegrationConfigMutation) {
		m.oldValue = func(context.Context) (*IntegrationConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IntegrationConfig entities.
func (m *IntegrationConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IntegrationConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IntegrationConfigMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IntegrationConfigMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldTenantID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *IntegrationConfigMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[integrationconfig.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *IntegrationConfigMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[integrationconfig.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IntegrationConfigMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, integrationconfig.FieldTenantID)
}

// SetService sets the "service" field.
func (m *IntegrationConfigMutation) SetService(s string) {
	m.service = &s
}

// Service returns the value of the "service" field in the mutation.
func (m *IntegrationConfigMutation) Service() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *IntegrationConfigMutation) ResetService() {
	m.service = nil
}

// SetConfigData sets the "config_data" field.
func (m *IntegrationConfigMutation) SetConfigData(s string) {
	m.config_data = &s
}

// ConfigData returns the value of the "config_data" field in the mutation.
func (m *IntegrationConfigMutation) ConfigData() (r string, exists bool) {
	v := m.config_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigData returns the old "config_data" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldConfigData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigData: %w", err)
	}
	return oldValue.ConfigData, nil
}

// ResetConfigData resets all changes to the "config_data" field.
func (m *IntegrationConfigMutation) ResetConfigData() {
	m.config_data = nil
}

// SetKeyID sets the "key_id" field.
func (m *IntegrationConfigMutation) SetKeyID(s string) {
	m.key_id = &s
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *IntegrationConfigMutation) KeyID() (r string, exists bool) {
	v := m.key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *IntegrationConfigMutation) ResetKeyID() {
	m.key_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IntegrationConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IntegrationConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IntegrationConfig entity.
// If the IntegrationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IntegrationConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IntegrationConfigMutation builder.
func (m *IntegrationConfigMutation) Where(ps ...predicate.IntegrationConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IntegrationConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IntegrationConfig).
func (m *IntegrationConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationConfigMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant_id != nil {
		fields = append(fields, integrationconfig.FieldTenantID)
	}
	if m.service != nil {
		fields = append(fields, integrationconfig.FieldService)
	}
	if m.config_data != nil {
		fields = append(fields, integrationconfig.FieldConfigData)
	}
	if m.key_id != nil {
		fields = append(fields, integrationconfig.FieldKeyID)
	}
	if m.created_at != nil {
		fields = append(fields, integrationconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, integrationconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integrationconfig.FieldTenantID:
		return m.TenantID()
	case integrationconfig.FieldService:
		return m.Service()
	case integrationconfig.FieldConfigData:
		return m.ConfigData()
	case integrationconfig.FieldKeyID:
		return m.KeyID()
	case integrationconfig.FieldCreatedAt:
		return m.CreatedAt()
	case integrationconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integrationconfig.FieldTenantID:
		return m.OldTenantID(ctx)
	case integrationconfig.FieldService:
		return m.OldService(ctx)
	case integrationconfig.FieldConfigData:
		return m.OldConfigData(ctx)
	case integrationconfig.FieldKeyID:
		return m.OldKeyID(ctx)
	case integrationconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integrationconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IntegrationConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integrationconfig.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case integrationconfig.FieldService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case integrationconfig.FieldConfigData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigData(v)
		return nil
	case integrationconfig.FieldKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case integrationconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integrationconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IntegrationConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IntegrationConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integrationconfig.FieldTenantID) {
		fields = append(fields, integrationconfig.FieldTenantID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationConfigMutation) ClearField(name string) error {
	switch name {
	case integrationconfig.FieldTenantID:
		m.ClearTenantID()
		return nil
	}
	return fmt.Errorf("unknown IntegrationConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationConfigMutation) ResetField(name string) error {
	switch name {
	case integrationconfig.FieldTenantID:
		m.ResetTenantID()
		return nil
	case integrationconfig.FieldService:
		m.ResetService()
		return nil
	case integrationconfig.FieldConfigData:
		m.ResetConfigData()
		return nil
	case integrationconfig.FieldKeyID:
		m.ResetKeyID()
		return nil
	case integrationconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integrationconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown IntegrationConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IntegrationConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IntegrationConfig edge %s", name)
}

// LoginAttemptMutation represents an operation that mutates the LoginAttempt nodes in the graph.
type LoginAttemptMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	tenant_id      *uuid.UUID
	user_id        *uuid.UUID
	email          *string
	ip_address     *string
	user_agent     *string
	success        *bool
	failure_reason *string
	occurred_at    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*LoginAttempt, error)
	predicates     []predicate.LoginAttempt
}

var _ ent.Mutation = (*LoginAttemptMutation)(nil)

// loginattemptOption allows management of the mutation configuration using functional options.
type loginattemptOption func(*LoginAttemptMutation)

// newLoginAttemptMutation creates new mutation for the LoginAttempt entity.
func newLoginAttemptMutation(c config, op Op, opts ...loginattemptOption) *LoginAttemptMutation {
	m := &LoginAttemptMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginAttempt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginAttemptID sets the ID field of the mutation.
func withLoginAttemptID(id uuid.UUID) loginattemptOption {
	return func(m *LoginAttemptMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginAttempt
		)
		m.oldValue = func(ctx context.Context) (*LoginAttempt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginAttempt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginAttempt sets the old LoginAttempt of the mutation.
func withLoginAttempt(node *LoginAttempt) loginattemptOption {
	return func(m *LoginAttemptMutation) {
		m.oldValue = func(context.Context) (*LoginAttempt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginAttemptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginAttemptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginAttempt entities.
func (m *LoginAttemptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginAttemptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginAttemptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginAttempt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *LoginAttemptMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LoginAttemptMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LoginAttemptMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[loginattempt.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LoginAttemptMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LoginAttemptMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, loginattempt.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *LoginAttemptMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginAttemptMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LoginAttemptMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[loginattempt.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LoginAttemptMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginAttemptMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, loginattempt.FieldUserID)
}

// SetEmail sets the "email" field.
func (m *LoginAttemptMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LoginAttemptMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *LoginAttemptMutation) ResetEmail() {
	m.email = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *LoginAttemptMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *LoginAttemptMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *LoginAttemptMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[loginattempt.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *LoginAttemptMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *LoginAttemptMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, loginattempt.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *LoginAttemptMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LoginAttemptMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LoginAttemptMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[loginattempt.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LoginAttemptMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LoginAttemptMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, loginattempt.FieldUserAgent)
}

// SetSuccess sets the "success" field.
func (m *LoginAttemptMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LoginAttemptMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *LoginAttemptMutation) ResetSuccess() {
	m.success = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *LoginAttemptMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *LoginAttemptMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldFailureReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *LoginAttemptMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[loginattempt.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *LoginAttemptMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[loginattempt.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *LoginAttemptMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, loginattempt.FieldFailureReason)
}

// SetOccurredAt sets the "occurred_at" field.
func (m *LoginAttemptMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *LoginAttemptMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the LoginAttempt entity.
// If the LoginAttempt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginAttemptMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *LoginAttemptMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// Where appends a list predicates to the LoginAttemptMutation builder.
func (m *LoginAttemptMutation) Where(ps ...predicate.LoginAttempt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LoginAttemptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LoginAttemptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LoginAttempt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LoginAttemptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LoginAttemptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LoginAttempt).
func (m *LoginAttemptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginAttemptMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant_id != nil {
		fields = append(fields, loginattempt.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, loginattempt.FieldUserID)
	}
	if m.email != nil {
		fields = append(fields, loginattempt.FieldEmail)
	}
	if m.ip_address != nil {
		fields = append(fields, loginattempt.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, loginattempt.FieldUserAgent)
	}
	if m.success != nil {
		fields = append(fields, loginattempt.FieldSuccess)
	}
	if m.failure_reason != nil {
		fields = append(fields, loginattempt.FieldFailureReason)
	}
	if m.occurred_at != nil {
		fields = append(fields, loginattempt.FieldOccurredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginAttemptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginattempt.FieldTenantID:
		return m.TenantID()
	case loginattempt.FieldUserID:
		return m.UserID()
	case loginattempt.FieldEmail:
		return m.Email()
	case loginattempt.FieldIPAddress:
		return m.IPAddress()
	case loginattempt.FieldUserAgent:
		return m.UserAgent()
	case loginattempt.FieldSuccess:
		return m.Success()
	case loginattempt.FieldFailureReason:
		return m.FailureReason()
	case loginattempt.FieldOccurredAt:
		return m.OccurredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginAttemptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginattempt.FieldTenantID:
		return m.OldTenantID(ctx)
	case loginattempt.FieldUserID:
		return m.OldUserID(ctx)
	case loginattempt.FieldEmail:
		return m.OldEmail(ctx)
	case loginattempt.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case loginattempt.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case loginattempt.FieldSuccess:
		return m.OldSuccess(ctx)
	case loginattempt.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case loginattempt.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	}
	return nil, fmt.Errorf("unknown LoginAttempt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginattempt.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case loginattempt.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case loginattempt.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case loginattempt.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case loginattempt.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case loginattempt.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case loginattempt.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case loginattempt.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginAttemptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginAttemptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginAttemptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LoginAttempt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginAttemptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginattempt.FieldTenantID) {
		fields = append(fields, loginattempt.FieldTenantID)
	}
	if m.FieldCleared(loginattempt.FieldUserID) {
		fields = append(fields, loginattempt.FieldUserID)
	}
	if m.FieldCleared(loginattempt.FieldIPAddress) {
		fields = append(fields, loginattempt.FieldIPAddress)
	}
	if m.FieldCleared(loginattempt.FieldUserAgent) {
		fields = append(fields, loginattempt.FieldUserAgent)
	}
	if m.FieldCleared(loginattempt.FieldFailureReason) {
		fields = append(fields, loginattempt.FieldFailureReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginAttemptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginAttemptMutation) ClearField(name string) error {
	switch name {
	case loginattempt.FieldTenantID:
		m.ClearTenantID()
		return nil
	case loginattempt.FieldUserID:
		m.ClearUserID()
		return nil
	case loginattempt.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case loginattempt.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case loginattempt.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginAttemptMutation) ResetField(name string) error {
	switch name {
	case loginattempt.FieldTenantID:
		m.ResetTenantID()
		return nil
	case loginattempt.FieldUserID:
		m.ResetUserID()
		return nil
	case loginattempt.FieldEmail:
		m.ResetEmail()
		return nil
	case loginattempt.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case loginattempt.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case loginattempt.FieldSuccess:
		m.ResetSuccess()
		return nil
	case loginattempt.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case loginattempt.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	}
	return fmt.Errorf("unknown LoginAttempt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginAttemptMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginAttemptMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginAttemptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginAttemptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginAttemptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginAttemptMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginAttemptMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginAttempt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginAttemptMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginAttempt edge %s", name)
}

// MFABackupCodeMutation represents an operation that mutates the MFABackupCode nodes in the graph.
type MFABackupCodeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	code_hash     *string
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*MFABackupCode, error)
	predicates    []predicate.MFABackupCode
}

var _ ent.Mutation = (*MFABackupCodeMutation)(nil)

// mfabackupcodeOption allows management of the mutation configuration using functional options.
type mfabackupcodeOption func(*MFABackupCodeMutation)

// newMFABackupCodeMutation creates new mutation for the MFABackupCode entity.
func newMFABackupCodeMutation(c config, op Op, opts ...mfabackupcodeOption) *MFABackupCodeMutation {
	m := &MFABackupCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeMFABackupCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFABackupCodeID sets the ID field of the mutation.
func withMFABackupCodeID(id uuid.UUID) mfabackupcodeOption {
	return func(m *MFABackupCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *MFABackupCode
		)
		m.oldValue = func(ctx context.Context) (*MFABackupCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFABackupCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFABackupCode sets the old MFABackupCode of the mutation.
func withMFABackupCode(node *MFABackupCode) mfabackupcodeOption {
	return func(m *MFABackupCodeMutation) {
		m.oldValue = func(context.Context) (*MFABackupCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFABackupCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFABackupCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MFABackupCode entities.
func (m *MFABackupCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MFABackupCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MFABackupCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MFABackupCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *MFABackupCodeMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MFABackupCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MFABackupCode entity.
// If the MFABackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFABackupCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MFABackupCodeMutation) ResetUserID() {
	m.user = nil
}

// SetCodeHash sets the "code_hash" field.
func (m *MFABackupCodeMutation) SetCodeHash(s string) {
	m.code_hash = &s
}

// CodeHash returns the value of the "code_hash" field in the mutation.
func (m *MFABackupCodeMutation) CodeHash() (r string, exists bool) {
	v := m.code_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeHash returns the old "code_hash" field's value of the MFABackupCode entity.
// If the MFABackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFABackupCodeMutation) OldCodeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeHash: %w", err)
	}
	return oldValue.CodeHash, nil
}

// ResetCodeHash resets all changes to the "code_hash" field.
func (m *MFABackupCodeMutation) ResetCodeHash() {
	m.code_hash = nil
}

// SetUsedAt sets the "used_at" field.
func (m *MFABackupCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *MFABackupCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the MFABackupCode entity.
// If the MFABackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFABackupCodeMutation) OldUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *MFABackupCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[mfabackupcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *MFABackupCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[mfabackupcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *MFABackupCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, mfabackupcode.FieldUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *MFABackupCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MFABackupCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MFABackupCode entity.
// If the MFABackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFABackupCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MFABackupCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MFABackupCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mfabackupcode.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MFABackupCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MFABackupCodeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MFABackupCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MFABackupCodeMutation builder.
func (m *MFABackupCodeMutation) Where(ps ...predicate.MFABackupCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MFABackupCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MFABackupCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MFABackupCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MFABackupCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MFABackupCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MFABackupCode).
func (m *MFABackupCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MFABackupCodeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, mfabackupcode.FieldUserID)
	}
	if m.code_hash != nil {
		fields = append(fields, mfabackupcode.FieldCodeHash)
	}
	if m.used_at != nil {
		fields = append(fields, mfabackupcode.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, mfabackupcode.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MFABackupCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfabackupcode.FieldUserID:
		return m.UserID()
	case mfabackupcode.FieldCodeHash:
		return m.CodeHash()
	case mfabackupcode.FieldUsedAt:
		return m.UsedAt()
	case mfabackupcode.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MFABackupCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfabackupcode.FieldUserID:
		return m.OldUserID(ctx)
	case mfabackupcode.FieldCodeHash:
		return m.OldCodeHash(ctx)
	case mfabackupcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case mfabackupcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MFABackupCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFABackupCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfabackupcode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mfabackupcode.FieldCodeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeHash(v)
		return nil
	case mfabackupcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case mfabackupcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MFABackupCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MFABackupCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MFABackupCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFABackupCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MFABackupCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MFABackupCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfabackupcode.FieldUsedAt) {
		fields = append(fields, mfabackupcode.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MFABackupCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFABackupCodeMutation) ClearField(name string) error {
	switch name {
	case mfabackupcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown MFABackupCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MFABackupCodeMutation) ResetField(name string) error {
	switch name {
	case mfabackupcode.FieldUserID:
		m.ResetUserID()
		return nil
	case mfabackupcode.FieldCodeHash:
		m.ResetCodeHash()
		return nil
	case mfabackupcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case mfabackupcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MFABackupCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MFABackupCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, mfabackupcode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MFABackupCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mfabackupcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MFABackupCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MFABackupCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MFABackupCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, mfabackupcode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MFABackupCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case mfabackupcode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MFABackupCodeMutation) ClearEdge(name string) error {
	switch name {
	case mfabackupcode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MFABackupCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MFABackupCodeMutation) ResetEdge(name string) error {
	switch name {
	case mfabackupcode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MFABackupCode edge %s", name)
}

// MFASettingsMutation represents an operation that mutates the MFASettings nodes in the graph.
type MFASettingsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	user_id          *uuid.UUID
	primary_method   *string
	enforced_at      *time.Time
	recovery_channel *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*MFASettings, error)
	predicates       []predicate.MFASettings
}

var _ ent.Mutation = (*MFASettingsMutation)(nil)

// mfasettingsOption allows management of the mutation configuration using functional options.
type mfasettingsOption func(*MFASettingsMutation)

// newMFASettingsMutation creates new mutation for the MFASettings entity.
func newMFASettingsMutation(c config, op Op, opts ...mfasettingsOption) *MFASettingsMutation {
	m := &MFASettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeMFASettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFASettingsID sets the ID field of the mutation.
func withMFASettingsID(id int) mfasettingsOption {
	return func(m *MFASettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *MFASettings
		)
		m.oldValue = func(ctx context.Context) (*MFASettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFASettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFASettings sets the old MFASettings of the mutation.
func withMFASettings(node *MFASettings) mfasettingsOption {
	return func(m *MFASettingsMutation) {
		m.oldValue = func(context.Context) (*MFASettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFASettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFASettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MFASettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MFASettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MFASettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *MFASettingsMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MFASettingsMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MFASettingsMutation) ResetUserID() {
	m.user_id = nil
}

// SetPrimaryMethod sets the "primary_method" field.
func (m *MFASettingsMutation) SetPrimaryMethod(s string) {
	m.primary_method = &s
}

// PrimaryMethod returns the value of the "primary_method" field in the mutation.
func (m *MFASettingsMutation) PrimaryMethod() (r string, exists bool) {
	v := m.primary_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryMethod returns the old "primary_method" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldPrimaryMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryMethod: %w", err)
	}
	return oldValue.PrimaryMethod, nil
}

// ResetPrimaryMethod resets all changes to the "primary_method" field.
func (m *MFASettingsMutation) ResetPrimaryMethod() {
	m.primary_method = nil
}

// SetEnforcedAt sets the "enforced_at" field.
func (m *MFASettingsMutation) SetEnforcedAt(t time.Time) {
	m.enforced_at = &t
}

// EnforcedAt returns the value of the "enforced_at" field in the mutation.
func (m *MFASettingsMutation) EnforcedAt() (r time.Time, exists bool) {
	v := m.enforced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforcedAt returns the old "enforced_at" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldEnforcedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforcedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforcedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforcedAt: %w", err)
	}
	return oldValue.EnforcedAt, nil
}

// ClearEnforcedAt clears the value of the "enforced_at" field.
func (m *MFASettingsMutation) ClearEnforcedAt() {
	m.enforced_at = nil
	m.clearedFields[mfasettings.FieldEnforcedAt] = struct{}{}
}

// EnforcedAtCleared returns if the "enforced_at" field was cleared in this mutation.
func (m *MFASettingsMutation) EnforcedAtCleared() bool {
	_, ok := m.clearedFields[mfasettings.FieldEnforcedAt]
	return ok
}

// ResetEnforcedAt resets all changes to the "enforced_at" field.
func (m *MFASettingsMutation) ResetEnforcedAt() {
	m.enforced_at = nil
	delete(m.clearedFields, mfasettings.FieldEnforcedAt)
}

// SetRecoveryChannel sets the "recovery_channel" field.
func (m *MFASettingsMutation) SetRecoveryChannel(s string) {
	m.recovery_channel = &s
}

// RecoveryChannel returns the value of the "recovery_channel" field in the mutation.
func (m *MFASettingsMutation) RecoveryChannel() (r string, exists bool) {
	v := m.recovery_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldRecoveryChannel returns the old "recovery_channel" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldRecoveryChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecoveryChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecoveryChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecoveryChannel: %w", err)
	}
	return oldValue.RecoveryChannel, nil
}

// ResetRecoveryChannel resets all changes to the "recovery_channel" field.
func (m *MFASettingsMutation) ResetRecoveryChannel() {
	m.recovery_channel = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MFASettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MFASettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MFASettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MFASettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MFASettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MFASettings entity.
// If the MFASettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFASettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MFASettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the MFASettingsMutation builder.
func (m *MFASettingsMutation) Where(ps ...predicate.MFASettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MFASettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MFASettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MFASettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MFASettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MFASettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MFASettings).
func (m *MFASettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MFASettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, mfasettings.FieldUserID)
	}
	if m.primary_method != nil {
		fields = append(fields, mfasettings.FieldPrimaryMethod)
	}
	if m.enforced_at != nil {
		fields = append(fields, mfasettings.FieldEnforcedAt)
	}
	if m.recovery_channel != nil {
		fields = append(fields, mfasettings.FieldRecoveryChannel)
	}
	if m.created_at != nil {
		fields = append(fields, mfasettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mfasettings.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MFASettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfasettings.FieldUserID:
		return m.UserID()
	case mfasettings.FieldPrimaryMethod:
		return m.PrimaryMethod()
	case mfasettings.FieldEnforcedAt:
		return m.EnforcedAt()
	case mfasettings.FieldRecoveryChannel:
		return m.RecoveryChannel()
	case mfasettings.FieldCreatedAt:
		return m.CreatedAt()
	case mfasettings.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MFASettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfasettings.FieldUserID:
		return m.OldUserID(ctx)
	case mfasettings.FieldPrimaryMethod:
		return m.OldPrimaryMethod(ctx)
	case mfasettings.FieldEnforcedAt:
		return m.OldEnforcedAt(ctx)
	case mfasettings.FieldRecoveryChannel:
		return m.OldRecoveryChannel(ctx)
	case mfasettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mfasettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MFASettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFASettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfasettings.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mfasettings.FieldPrimaryMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryMethod(v)
		return nil
	case mfasettings.FieldEnforcedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforcedAt(v)
		return nil
	case mfasettings.FieldRecoveryChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecoveryChannel(v)
		return nil
	case mfasettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mfasettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MFASettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MFASettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MFASettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFASettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MFASettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MFASettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfasettings.FieldEnforcedAt) {
		fields = append(fields, mfasettings.FieldEnforcedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MFASettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFASettingsMutation) ClearField(name string) error {
	switch name {
	case mfasettings.FieldEnforcedAt:
		m.ClearEnforcedAt()
		return nil
	}
	return fmt.Errorf("unknown MFASettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MFASettingsMutation) ResetField(name string) error {
	switch name {
	case mfasettings.FieldUserID:
		m.ResetUserID()
		return nil
	case mfasettings.FieldPrimaryMethod:
		m.ResetPrimaryMethod()
		return nil
	case mfasettings.FieldEnforcedAt:
		m.ResetEnforcedAt()
		return nil
	case mfasettings.FieldRecoveryChannel:
		m.ResetRecoveryChannel()
		return nil
	case mfasettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mfasettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MFASettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MFASettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MFASettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MFASettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MFASettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MFASettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MFASettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MFASettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MFASettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MFASettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MFASettings edge %s", name)
}

// MFATOTPSecretMutation represents an operation that mutates the MFATOTPSecret nodes in the graph.
type MFATOTPSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	secret        *string
	digits        *int
	adddigits     *int
	period        *int
	addperiod     *int
	enabled_at    *time.Time
	last_used_at  *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*MFATOTPSecret, error)
	predicates    []predicate.MFATOTPSecret
}

var _ ent.Mutation = (*MFATOTPSecretMutation)(nil)

// mfatotpsecretOption allows management of the mutation configuration using functional options.
type mfatotpsecretOption func(*MFATOTPSecretMutation)

// newMFATOTPSecretMutation creates new mutation for the MFATOTPSecret entity.
func newMFATOTPSecretMutation(c config, op Op, opts ...mfatotpsecretOption) *MFATOTPSecretMutation {
	m := &MFATOTPSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeMFATOTPSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFATOTPSecretID sets the ID field of the mutation.
func withMFATOTPSecretID(id uuid.UUID) mfatotpsecretOption {
	return func(m *MFATOTPSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *MFATOTPSecret
		)
		m.oldValue = func(ctx context.Context) (*MFATOTPSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFATOTPSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFATOTPSecret sets the old MFATOTPSecret of the mutation.
func withMFATOTPSecret(node *MFATOTPSecret) mfatotpsecretOption {
	return func(m *MFATOTPSecretMutation) {
		m.oldValue = func(context.Context) (*MFATOTPSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFATOTPSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFATOTPSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MFATOTPSecret entities.
func (m *MFATOTPSecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MFATOTPSecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MFATOTPSecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MFATOTPSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *MFATOTPSecretMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MFATOTPSecretMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MFATOTPSecretMutation) ResetUserID() {
	m.user = nil
}

// SetSecret sets the "secret" field.
func (m *MFATOTPSecretMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *MFATOTPSecretMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *MFATOTPSecretMutation) ResetSecret() {
	m.secret = nil
}

// SetDigits sets the "digits" field.
func (m *MFATOTPSecretMutation) SetDigits(i int) {
	m.digits = &i
	m.adddigits = nil
}

// Digits returns the value of the "digits" field in the mutation.
func (m *MFATOTPSecretMutation) Digits() (r int, exists bool) {
	v := m.digits
	if v == nil {
		return
	}
	return *v, true
}

// OldDigits returns the old "digits" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldDigits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigits: %w", err)
	}
	return oldValue.Digits, nil
}

// AddDigits adds i to the "digits" field.
func (m *MFATOTPSecretMutation) AddDigits(i int) {
	if m.adddigits != nil {
		*m.adddigits += i
	} else {
		m.adddigits = &i
	}
}

// AddedDigits returns the value that was added to the "digits" field in this mutation.
func (m *MFATOTPSecretMutation) AddedDigits() (r int, exists bool) {
	v := m.adddigits
	if v == nil {
		return
	}
	return *v, true
}

// ResetDigits resets all changes to the "digits" field.
func (m *MFATOTPSecretMutation) ResetDigits() {
	m.digits = nil
	m.adddigits = nil
}

// SetPeriod sets the "period" field.
func (m *MFATOTPSecretMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *MFATOTPSecretMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *MFATOTPSecretMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *MFATOTPSecretMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *MFATOTPSecretMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetEnabledAt sets the "enabled_at" field.
func (m *MFATOTPSecretMutation) SetEnabledAt(t time.Time) {
	m.enabled_at = &t
}

// EnabledAt returns the value of the "enabled_at" field in the mutation.
func (m *MFATOTPSecretMutation) EnabledAt() (r time.Time, exists bool) {
	v := m.enabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabledAt returns the old "enabled_at" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldEnabledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabledAt: %w", err)
	}
	return oldValue.EnabledAt, nil
}

// ClearEnabledAt clears the value of the "enabled_at" field.
func (m *MFATOTPSecretMutation) ClearEnabledAt() {
	m.enabled_at = nil
	m.clearedFields[mfatotpsecret.FieldEnabledAt] = struct{}{}
}

// EnabledAtCleared returns if the "enabled_at" field was cleared in this mutation.
func (m *MFATOTPSecretMutation) EnabledAtCleared() bool {
	_, ok := m.clearedFields[mfatotpsecret.FieldEnabledAt]
	return ok
}

// ResetEnabledAt resets all changes to the "enabled_at" field.
func (m *MFATOTPSecretMutation) ResetEnabledAt() {
	m.enabled_at = nil
	delete(m.clearedFields, mfatotpsecret.FieldEnabledAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *MFATOTPSecretMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *MFATOTPSecretMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *MFATOTPSecretMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[mfatotpsecret.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *MFATOTPSecretMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[mfatotpsecret.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *MFATOTPSecretMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, mfatotpsecret.FieldLastUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *MFATOTPSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MFATOTPSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MFATOTPSecret entity.
// If the MFATOTPSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MFATOTPSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MFATOTPSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *MFATOTPSecretMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[mfatotpsecret.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MFATOTPSecretMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MFATOTPSecretMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MFATOTPSecretMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MFATOTPSecretMutation builder.
func (m *MFATOTPSecretMutation) Where(ps ...predicate.MFATOTPSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MFATOTPSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MFATOTPSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MFATOTPSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MFATOTPSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MFATOTPSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MFATOTPSecret).
func (m *MFATOTPSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MFATOTPSecretMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, mfatotpsecret.FieldUserID)
	}
	if m.secret != nil {
		fields = append(fields, mfatotpsecret.FieldSecret)
	}
	if m.digits != nil {
		fields = append(fields, mfatotpsecret.FieldDigits)
	}
	if m.period != nil {
		fields = append(fields, mfatotpsecret.FieldPeriod)
	}
	if m.enabled_at != nil {
		fields = append(fields, mfatotpsecret.FieldEnabledAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, mfatotpsecret.FieldLastUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, mfatotpsecret.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MFATOTPSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfatotpsecret.FieldUserID:
		return m.UserID()
	case mfatotpsecret.FieldSecret:
		return m.Secret()
	case mfatotpsecret.FieldDigits:
		return m.Digits()
	case mfatotpsecret.FieldPeriod:
		return m.Period()
	case mfatotpsecret.FieldEnabledAt:
		return m.EnabledAt()
	case mfatotpsecret.FieldLastUsedAt:
		return m.LastUsedAt()
	case mfatotpsecret.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MFATOTPSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfatotpsecret.FieldUserID:
		return m.OldUserID(ctx)
	case mfatotpsecret.FieldSecret:
		return m.OldSecret(ctx)
	case mfatotpsecret.FieldDigits:
		return m.OldDigits(ctx)
	case mfatotpsecret.FieldPeriod:
		return m.OldPeriod(ctx)
	case mfatotpsecret.FieldEnabledAt:
		return m.OldEnabledAt(ctx)
	case mfatotpsecret.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case mfatotpsecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MFATOTPSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFATOTPSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfatotpsecret.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case mfatotpsecret.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case mfatotpsecret.FieldDigits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigits(v)
		return nil
	case mfatotpsecret.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case mfatotpsecret.FieldEnabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabledAt(v)
		return nil
	case mfatotpsecret.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case mfatotpsecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MFATOTPSecretMutation) AddedFields() []string {
	var fields []string
	if m.adddigits != nil {
		fields = append(fields, mfatotpsecret.FieldDigits)
	}
	if m.addperiod != nil {
		fields = append(fields, mfatotpsecret.FieldPeriod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MFATOTPSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mfatotpsecret.FieldDigits:
		return m.AddedDigits()
	case mfatotpsecret.FieldPeriod:
		return m.AddedPeriod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MFATOTPSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mfatotpsecret.FieldDigits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDigits(v)
		return nil
	case mfatotpsecret.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MFATOTPSecretMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfatotpsecret.FieldEnabledAt) {
		fields = append(fields, mfatotpsecret.FieldEnabledAt)
	}
	if m.FieldCleared(mfatotpsecret.FieldLastUsedAt) {
		fields = append(fields, mfatotpsecret.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MFATOTPSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFATOTPSecretMutation) ClearField(name string) error {
	switch name {
	case mfatotpsecret.FieldEnabledAt:
		m.ClearEnabledAt()
		return nil
	case mfatotpsecret.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MFATOTPSecretMutation) ResetField(name string) error {
	switch name {
	case mfatotpsecret.FieldUserID:
		m.ResetUserID()
		return nil
	case mfatotpsecret.FieldSecret:
		m.ResetSecret()
		return nil
	case mfatotpsecret.FieldDigits:
		m.ResetDigits()
		return nil
	case mfatotpsecret.FieldPeriod:
		m.ResetPeriod()
		return nil
	case mfatotpsecret.FieldEnabledAt:
		m.ResetEnabledAt()
		return nil
	case mfatotpsecret.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case mfatotpsecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MFATOTPSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, mfatotpsecret.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MFATOTPSecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mfatotpsecret.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MFATOTPSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MFATOTPSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MFATOTPSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, mfatotpsecret.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MFATOTPSecretMutation) EdgeCleared(name string) bool {
	switch name {
	case mfatotpsecret.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MFATOTPSecretMutation) ClearEdge(name string) error {
	switch name {
	case mfatotpsecret.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MFATOTPSecretMutation) ResetEdge(name string) error {
	switch name {
	case mfatotpsecret.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown MFATOTPSecret edge %s", name)
}

// OAuthClientMutation represents an operation that mutates the OAuthClient nodes in the graph.
type OAuthClientMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	client_id            *string
	client_secret        *string
	name                 *string
	redirect_uris        *[]string
	appendredirect_uris  []string
	allowed_scopes       *[]string
	appendallowed_scopes []string
	public               *bool
	tenant_id            *string
	metadata             *map[string]interface{}
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*OAuthClient, error)
	predicates           []predicate.OAuthClient
}

var _ ent.Mutation = (*OAuthClientMutation)(nil)

// oauthclientOption allows management of the mutation configuration using functional options.
type oauthclientOption func(*OAuthClientMutation)

// newOAuthClientMutation creates new mutation for the OAuthClient entity.
func newOAuthClientMutation(c config, op Op, opts ...oauthclientOption) *OAuthClientMutation {
	m := &OAuthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthClientID sets the ID field of the mutation.
func withOAuthClientID(id uuid.UUID) oauthclientOption {
	return func(m *OAuthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthClient
		)
		m.oldValue = func(ctx context.Context) (*OAuthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthClient sets the old OAuthClient of the mutation.
func withOAuthClient(node *OAuthClient) oauthclientOption {
	return func(m *OAuthClientMutation) {
		m.oldValue = func(context.Context) (*OAuthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthClient entities.
func (m *OAuthClientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthClientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthClientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *OAuthClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OAuthClientMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OAuthClientMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *OAuthClientMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[oauthclient.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *OAuthClientMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OAuthClientMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, oauthclient.FieldClientSecret)
}

// SetName sets the "name" field.
func (m *OAuthClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OAuthClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OAuthClientMutation) ResetName() {
	m.name = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *OAuthClientMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *OAuthClientMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *OAuthClientMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *OAuthClientMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ClearRedirectUris clears the value of the "redirect_uris" field.
func (m *OAuthClientMutation) ClearRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
	m.clearedFields[oauthclient.FieldRedirectUris] = struct{}{}
}

// RedirectUrisCleared returns if the "redirect_uris" field was cleared in this mutation.
func (m *OAuthClientMutation) RedirectUrisCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldRedirectUris]
	return ok
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *OAuthClientMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
	delete(m.clearedFields, oauthclient.FieldRedirectUris)
}

// SetAllowedScopes sets the "allowed_scopes" field.
func (m *OAuthClientMutation) SetAllowedScopes(s []string) {
	m.allowed_scopes = &s
	m.appendallowed_scopes = nil
}

// AllowedScopes returns the value of the "allowed_scopes" field in the mutation.
func (m *OAuthClientMutation) AllowedScopes() (r []string, exists bool) {
	v := m.allowed_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedScopes returns the old "allowed_scopes" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldAllowedScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedScopes: %w", err)
	}
	return oldValue.AllowedScopes, nil
}

// AppendAllowedScopes adds s to the "allowed_scopes" field.
func (m *OAuthClientMutation) AppendAllowedScopes(s []string) {
	m.appendallowed_scopes = append(m.appendallowed_scopes, s...)
}

// AppendedAllowedScopes returns the list of values that were appended to the "allowed_scopes" field in this mutation.
func (m *OAuthClientMutation) AppendedAllowedScopes() ([]string, bool) {
	if len(m.appendallowed_scopes) == 0 {
		return nil, false
	}
	return m.appendallowed_scopes, true
}

// ClearAllowedScopes clears the value of the "allowed_scopes" field.
func (m *OAuthClientMutation) ClearAllowedScopes() {
	m.allowed_scopes = nil
	m.appendallowed_scopes = nil
	m.clearedFields[oauthclient.FieldAllowedScopes] = struct{}{}
}

// AllowedScopesCleared returns if the "allowed_scopes" field was cleared in this mutation.
func (m *OAuthClientMutation) AllowedScopesCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldAllowedScopes]
	return ok
}

// ResetAllowedScopes resets all changes to the "allowed_scopes" field.
func (m *OAuthClientMutation) ResetAllowedScopes() {
	m.allowed_scopes = nil
	m.appendallowed_scopes = nil
	delete(m.clearedFields, oauthclient.FieldAllowedScopes)
}

// SetPublic sets the "public" field.
func (m *OAuthClientMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *OAuthClientMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *OAuthClientMutation) ResetPublic() {
	m.public = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *OAuthClientMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OAuthClientMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *OAuthClientMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[oauthclient.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *OAuthClientMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OAuthClientMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, oauthclient.FieldTenantID)
}

// SetMetadata sets the "metadata" field.
func (m *OAuthClientMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *OAuthClientMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *OAuthClientMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[oauthclient.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *OAuthClientMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *OAuthClientMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, oauthclient.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthClient entity.
// If the OAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the OAuthClientMutation builder.
func (m *OAuthClientMutation) Where(ps ...predicate.OAuthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthClient).
func (m *OAuthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthClientMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.client_id != nil {
		fields = append(fields, oauthclient.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthclient.FieldClientSecret)
	}
	if m.name != nil {
		fields = append(fields, oauthclient.FieldName)
	}
	if m.redirect_uris != nil {
		fields = append(fields, oauthclient.FieldRedirectUris)
	}
	if m.allowed_scopes != nil {
		fields = append(fields, oauthclient.FieldAllowedScopes)
	}
	if m.public != nil {
		fields = append(fields, oauthclient.FieldPublic)
	}
	if m.tenant_id != nil {
		fields = append(fields, oauthclient.FieldTenantID)
	}
	if m.metadata != nil {
		fields = append(fields, oauthclient.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, oauthclient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthclient.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldClientID:
		return m.ClientID()
	case oauthclient.FieldClientSecret:
		return m.ClientSecret()
	case oauthclient.FieldName:
		return m.Name()
	case oauthclient.FieldRedirectUris:
		return m.RedirectUris()
	case oauthclient.FieldAllowedScopes:
		return m.AllowedScopes()
	case oauthclient.FieldPublic:
		return m.Public()
	case oauthclient.FieldTenantID:
		return m.TenantID()
	case oauthclient.FieldMetadata:
		return m.Metadata()
	case oauthclient.FieldCreatedAt:
		return m.CreatedAt()
	case oauthclient.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthclient.FieldClientID:
		return m.OldClientID(ctx)
	case oauthclient.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthclient.FieldName:
		return m.OldName(ctx)
	case oauthclient.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case oauthclient.FieldAllowedScopes:
		return m.OldAllowedScopes(ctx)
	case oauthclient.FieldPublic:
		return m.OldPublic(ctx)
	case oauthclient.FieldTenantID:
		return m.OldTenantID(ctx)
	case oauthclient.FieldMetadata:
		return m.OldMetadata(ctx)
	case oauthclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthclient.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthclient.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case oauthclient.FieldAllowedScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedScopes(v)
		return nil
	case oauthclient.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case oauthclient.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case oauthclient.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case oauthclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OAuthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthclient.FieldClientSecret) {
		fields = append(fields, oauthclient.FieldClientSecret)
	}
	if m.FieldCleared(oauthclient.FieldRedirectUris) {
		fields = append(fields, oauthclient.FieldRedirectUris)
	}
	if m.FieldCleared(oauthclient.FieldAllowedScopes) {
		fields = append(fields, oauthclient.FieldAllowedScopes)
	}
	if m.FieldCleared(oauthclient.FieldTenantID) {
		fields = append(fields, oauthclient.FieldTenantID)
	}
	if m.FieldCleared(oauthclient.FieldMetadata) {
		fields = append(fields, oauthclient.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthClientMutation) ClearField(name string) error {
	switch name {
	case oauthclient.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case oauthclient.FieldRedirectUris:
		m.ClearRedirectUris()
		return nil
	case oauthclient.FieldAllowedScopes:
		m.ClearAllowedScopes()
		return nil
	case oauthclient.FieldTenantID:
		m.ClearTenantID()
		return nil
	case oauthclient.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthClientMutation) ResetField(name string) error {
	switch name {
	case oauthclient.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthclient.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthclient.FieldName:
		m.ResetName()
		return nil
	case oauthclient.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case oauthclient.FieldAllowedScopes:
		m.ResetAllowedScopes()
		return nil
	case oauthclient.FieldPublic:
		m.ResetPublic()
		return nil
	case oauthclient.FieldTenantID:
		m.ResetTenantID()
		return nil
	case oauthclient.FieldMetadata:
		m.ResetMetadata()
		return nil
	case oauthclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OAuthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OAuthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OAuthClient edge %s", name)
}

// PasswordResetTokenMutation represents an operation that mutates the PasswordResetToken nodes in the graph.
type PasswordResetTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordResetToken, error)
	predicates    []predicate.PasswordResetToken
}

var _ ent.Mutation = (*PasswordResetTokenMutation)(nil)

// passwordresettokenOption allows management of the mutation configuration using functional options.
type passwordresettokenOption func(*PasswordResetTokenMutation)

// newPasswordResetTokenMutation creates new mutation for the PasswordResetToken entity.
func newPasswordResetTokenMutation(c config, op Op, opts ...passwordresettokenOption) *PasswordResetTokenMutation {
	m := &PasswordResetTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetTokenID sets the ID field of the mutation.
func withPasswordResetTokenID(id uuid.UUID) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetToken sets the old PasswordResetToken of the mutation.
func withPasswordResetToken(node *PasswordResetToken) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordResetToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PasswordResetToken entities.
func (m *PasswordResetTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PasswordResetTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordResetTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordResetTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *PasswordResetTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *PasswordResetTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *PasswordResetTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PasswordResetTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PasswordResetTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PasswordResetTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *PasswordResetTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *PasswordResetTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *PasswordResetTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[passwordresettoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *PasswordResetTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, passwordresettoken.FieldUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordResetTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordResetTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordResetTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passwordresettoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordResetTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordResetTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordResetTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordResetTokenMutation builder.
func (m *PasswordResetTokenMutation) Where(ps ...predicate.PasswordResetToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetToken).
func (m *PasswordResetTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, passwordresettoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, passwordresettoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, passwordresettoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresettoken.FieldUserID:
		return m.UserID()
	case passwordresettoken.FieldTokenHash:
		return m.TokenHash()
	case passwordresettoken.FieldExpiresAt:
		return m.ExpiresAt()
	case passwordresettoken.FieldUsedAt:
		return m.UsedAt()
	case passwordresettoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresettoken.FieldUserID:
		return m.OldUserID(ctx)
	case passwordresettoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case passwordresettoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case passwordresettoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case passwordresettoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresettoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passwordresettoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case passwordresettoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case passwordresettoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case passwordresettoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordresettoken.FieldUsedAt) {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearField(name string) error {
	switch name {
	case passwordresettoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetField(name string) error {
	switch name {
	case passwordresettoken.FieldUserID:
		m.ResetUserID()
		return nil
	case passwordresettoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case passwordresettoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case passwordresettoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case passwordresettoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresettoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresettoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	tenant_id          *uuid.UUID
	client_id          *string
	session_type       *string
	status             *string
	refresh_token_hash *string
	issued_at          *time.Time
	expires_at         *time.Time
	revoked_at         *time.Time
	revocation_reason  *string
	ip_address         *string
	user_agent         *string
	metadata           *map[string]interface{}
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Session, error)
	predicates         []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *SessionMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SessionMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *SessionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[session.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *SessionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[session.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SessionMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, session.FieldTenantID)
}

// SetClientID sets the "client_id" field.
func (m *SessionMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *SessionMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *SessionMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[session.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *SessionMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[session.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *SessionMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, session.FieldClientID)
}

// SetSessionType sets the "session_type" field.
func (m *SessionMutation) SetSessionType(s string) {
	m.session_type = &s
}

// SessionType returns the value of the "session_type" field in the mutation.
func (m *SessionMutation) SessionType() (r string, exists bool) {
	v := m.session_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionType returns the old "session_type" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldSessionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionType: %w", err)
	}
	return oldValue.SessionType, nil
}

// ResetSessionType resets all changes to the "session_type" field.
func (m *SessionMutation) ResetSessionType() {
	m.session_type = nil
}

// SetStatus sets the "status" field.
func (m *SessionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SessionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SessionMutation) ResetStatus() {
	m.status = nil
}

// SetRefreshTokenHash sets the "refresh_token_hash" field.
func (m *SessionMutation) SetRefreshTokenHash(s string) {
	m.refresh_token_hash = &s
}

// RefreshTokenHash returns the value of the "refresh_token_hash" field in the mutation.
func (m *SessionMutation) RefreshTokenHash() (r string, exists bool) {
	v := m.refresh_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenHash returns the old "refresh_token_hash" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenHash: %w", err)
	}
	return oldValue.RefreshTokenHash, nil
}

// ResetRefreshTokenHash resets all changes to the "refresh_token_hash" field.
func (m *SessionMutation) ResetRefreshTokenHash() {
	m.refresh_token_hash = nil
}

// SetIssuedAt sets the "issued_at" field.
func (m *SessionMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *SessionMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIssuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *SessionMutation) ResetIssuedAt() {
	m.issued_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevocationReason sets the "revocation_reason" field.
func (m *SessionMutation) SetRevocationReason(s string) {
	m.revocation_reason = &s
}

// RevocationReason returns the value of the "revocation_reason" field in the mutation.
func (m *SessionMutation) RevocationReason() (r string, exists bool) {
	v := m.revocation_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevocationReason returns the old "revocation_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevocationReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevocationReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevocationReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevocationReason: %w", err)
	}
	return oldValue.RevocationReason, nil
}

// ClearRevocationReason clears the value of the "revocation_reason" field.
func (m *SessionMutation) ClearRevocationReason() {
	m.revocation_reason = nil
	m.clearedFields[session.FieldRevocationReason] = struct{}{}
}

// RevocationReasonCleared returns if the "revocation_reason" field was cleared in this mutation.
func (m *SessionMutation) RevocationReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevocationReason]
	return ok
}

// ResetRevocationReason resets all changes to the "revocation_reason" field.
func (m *SessionMutation) ResetRevocationReason() {
	m.revocation_reason = nil
	delete(m.clearedFields, session.FieldRevocationReason)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *SessionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SessionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SessionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[session.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SessionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[session.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SessionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, session.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.tenant_id != nil {
		fields = append(fields, session.FieldTenantID)
	}
	if m.client_id != nil {
		fields = append(fields, session.FieldClientID)
	}
	if m.session_type != nil {
		fields = append(fields, session.FieldSessionType)
	}
	if m.status != nil {
		fields = append(fields, session.FieldStatus)
	}
	if m.refresh_token_hash != nil {
		fields = append(fields, session.FieldRefreshTokenHash)
	}
	if m.issued_at != nil {
		fields = append(fields, session.FieldIssuedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revocation_reason != nil {
		fields = append(fields, session.FieldRevocationReason)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, session.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldTenantID:
		return m.TenantID()
	case session.FieldClientID:
		return m.ClientID()
	case session.FieldSessionType:
		return m.SessionType()
	case session.FieldStatus:
		return m.Status()
	case session.FieldRefreshTokenHash:
		return m.RefreshTokenHash()
	case session.FieldIssuedAt:
		return m.IssuedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevocationReason:
		return m.RevocationReason()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldMetadata:
		return m.Metadata()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldTenantID:
		return m.OldTenantID(ctx)
	case session.FieldClientID:
		return m.OldClientID(ctx)
	case session.FieldSessionType:
		return m.OldSessionType(ctx)
	case session.FieldStatus:
		return m.OldStatus(ctx)
	case session.FieldRefreshTokenHash:
		return m.OldRefreshTokenHash(ctx)
	case session.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevocationReason:
		return m.OldRevocationReason(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldMetadata:
		return m.OldMetadata(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case session.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case session.FieldSessionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionType(v)
		return nil
	case session.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case session.FieldRefreshTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenHash(v)
		return nil
	case session.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevocationReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevocationReason(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldTenantID) {
		fields = append(fields, session.FieldTenantID)
	}
	if m.FieldCleared(session.FieldClientID) {
		fields = append(fields, session.FieldClientID)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevocationReason) {
		fields = append(fields, session.FieldRevocationReason)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldMetadata) {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldTenantID:
		m.ClearTenantID()
		return nil
	case session.FieldClientID:
		m.ClearClientID()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevocationReason:
		m.ClearRevocationReason()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldTenantID:
		m.ResetTenantID()
		return nil
	case session.FieldClientID:
		m.ResetClientID()
		return nil
	case session.FieldSessionType:
		m.ResetSessionType()
		return nil
	case session.FieldStatus:
		m.ResetStatus()
		return nil
	case session.FieldRefreshTokenHash:
		m.ResetRefreshTokenHash()
		return nil
	case session.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevocationReason:
		m.ResetRevocationReason()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldMetadata:
		m.ResetMetadata()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	slug               *string
	status             *string
	metadata           *map[string]interface{}
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	memberships        map[uuid.UUID]struct{}
	removedmemberships map[uuid.UUID]struct{}
	clearedmemberships bool
	done               bool
	oldValue           func(context.Context) (*Tenant, error)
	predicates         []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id uuid.UUID) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *TenantMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TenantMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TenantMutation) ResetSlug() {
	m.slug = nil
}

// SetStatus sets the "status" field.
func (m *TenantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *TenantMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TenantMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TenantMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[tenant.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TenantMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[tenant.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TenantMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, tenant.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddMembershipIDs adds the "memberships" edge to the TenantMembership entity by ids.
func (m *TenantMutation) AddMembershipIDs(ids ...uuid.UUID) {
	if m.memberships == nil {
		m.memberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the TenantMembership entity.
func (m *TenantMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the TenantMembership entity was cleared.
func (m *TenantMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the TenantMembership entity by IDs.
func (m *TenantMutation) RemoveMembershipIDs(ids ...uuid.UUID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the TenantMembership entity.
func (m *TenantMutation) RemovedMembershipsIDs() (ids []uuid.UUID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *TenantMutation) MembershipsIDs() (ids []uuid.UUID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *TenantMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, tenant.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, tenant.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, tenant.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldSlug:
		return m.Slug()
	case tenant.FieldStatus:
		return m.Status()
	case tenant.FieldMetadata:
		return m.Metadata()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldSlug:
		return m.OldSlug(ctx)
	case tenant.FieldStatus:
		return m.OldStatus(ctx)
	case tenant.FieldMetadata:
		return m.OldMetadata(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tenant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenant.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldMetadata) {
		fields = append(fields, tenant.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldSlug:
		m.ResetSlug()
		return nil
	case tenant.FieldStatus:
		m.ResetStatus()
		return nil
	case tenant.FieldMetadata:
		m.ResetMetadata()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.memberships != nil {
		edges = append(edges, tenant.EdgeMemberships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmemberships != nil {
		edges = append(edges, tenant.EdgeMemberships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmemberships {
		edges = append(edges, tenant.EdgeMemberships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeMemberships:
		return m.clearedmemberships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeMemberships:
		m.ResetMemberships()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TenantMembershipMutation represents an operation that mutates the TenantMembership nodes in the graph.
type TenantMembershipMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	roles         *[]string
	appendroles   []string
	status        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	tenant        *uuid.UUID
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*TenantMembership, error)
	predicates    []predicate.TenantMembership
}

var _ ent.Mutation = (*TenantMembershipMutation)(nil)

// tenantmembershipOption allows management of the mutation configuration using functional options.
type tenantmembershipOption func(*TenantMembershipMutation)

// newTenantMembershipMutation creates new mutation for the TenantMembership entity.
func newTenantMembershipMutation(c config, op Op, opts ...tenantmembershipOption) *TenantMembershipMutation {
	m := &TenantMembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantMembershipID sets the ID field of the mutation.
func withTenantMembershipID(id uuid.UUID) tenantmembershipOption {
	return func(m *TenantMembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantMembership
		)
		m.oldValue = func(ctx context.Context) (*TenantMembership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantMembership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantMembership sets the old TenantMembership of the mutation.
func withTenantMembership(node *TenantMembership) tenantmembershipOption {
	return func(m *TenantMembershipMutation) {
		m.oldValue = func(context.Context) (*TenantMembership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantMembership entities.
func (m *TenantMembershipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMembershipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMembershipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantMembership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TenantMembershipMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TenantMembershipMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TenantMembershipMutation) ResetUserID() {
	m.user = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantMembershipMutation) SetTenantID(u uuid.UUID) {
	m.tenant = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantMembershipMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantMembershipMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRoles sets the "roles" field.
func (m *TenantMembershipMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *TenantMembershipMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *TenantMembershipMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *TenantMembershipMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ClearRoles clears the value of the "roles" field.
func (m *TenantMembershipMutation) ClearRoles() {
	m.roles = nil
	m.appendroles = nil
	m.clearedFields[tenantmembership.FieldRoles] = struct{}{}
}

// RolesCleared returns if the "roles" field was cleared in this mutation.
func (m *TenantMembershipMutation) RolesCleared() bool {
	_, ok := m.clearedFields[tenantmembership.FieldRoles]
	return ok
}

// ResetRoles resets all changes to the "roles" field.
func (m *TenantMembershipMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
	delete(m.clearedFields, tenantmembership.FieldRoles)
}

// SetStatus sets the "status" field.
func (m *TenantMembershipMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TenantMembershipMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TenantMembershipMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMembershipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantMembership entity.
// If the TenantMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMembershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TenantMembershipMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[tenantmembership.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TenantMembershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TenantMembershipMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TenantMembershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TenantMembershipMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[tenantmembership.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TenantMembershipMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TenantMembershipMutation) TenantIDs() (ids []uuid.UUID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TenantMembershipMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the TenantMembershipMutation builder.
func (m *TenantMembershipMutation) Where(ps ...predicate.TenantMembership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantMembership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantMembership).
func (m *TenantMembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMembershipMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, tenantmembership.FieldUserID)
	}
	if m.tenant != nil {
		fields = append(fields, tenantmembership.FieldTenantID)
	}
	if m.roles != nil {
		fields = append(fields, tenantmembership.FieldRoles)
	}
	if m.status != nil {
		fields = append(fields, tenantmembership.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, tenantmembership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantmembership.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantmembership.FieldUserID:
		return m.UserID()
	case tenantmembership.FieldTenantID:
		return m.TenantID()
	case tenantmembership.FieldRoles:
		return m.Roles()
	case tenantmembership.FieldStatus:
		return m.Status()
	case tenantmembership.FieldCreatedAt:
		return m.CreatedAt()
	case tenantmembership.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantmembership.FieldUserID:
		return m.OldUserID(ctx)
	case tenantmembership.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantmembership.FieldRoles:
		return m.OldRoles(ctx)
	case tenantmembership.FieldStatus:
		return m.OldStatus(ctx)
	case tenantmembership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantmembership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TenantMembership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantmembership.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tenantmembership.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantmembership.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	case tenantmembership.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenantmembership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantmembership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TenantMembership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TenantMembership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantmembership.FieldRoles) {
		fields = append(fields, tenantmembership.FieldRoles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMembershipMutation) ClearField(name string) error {
	switch name {
	case tenantmembership.FieldRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown TenantMembership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMembershipMutation) ResetField(name string) error {
	switch name {
	case tenantmembership.FieldUserID:
		m.ResetUserID()
		return nil
	case tenantmembership.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantmembership.FieldRoles:
		m.ResetRoles()
		return nil
	case tenantmembership.FieldStatus:
		m.ResetStatus()
		return nil
	case tenantmembership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantmembership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TenantMembership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, tenantmembership.EdgeUser)
	}
	if m.tenant != nil {
		edges = append(edges, tenantmembership.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenantmembership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tenantmembership.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, tenantmembership.EdgeUser)
	}
	if m.clearedtenant {
		edges = append(edges, tenantmembership.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case tenantmembership.EdgeUser:
		return m.cleareduser
	case tenantmembership.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMembershipMutation) ClearEdge(name string) error {
	switch name {
	case tenantmembership.EdgeUser:
		m.ClearUser()
		return nil
	case tenantmembership.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown TenantMembership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMembershipMutation) ResetEdge(name string) error {
	switch name {
	case tenantmembership.EdgeUser:
		m.ResetUser()
		return nil
	case tenantmembership.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown TenantMembership edge %s", name)
}

// UsageMetricMutation represents an operation that mutates the UsageMetric nodes in the graph.
type UsageMetricMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	tenant_id            *uuid.UUID
	metric_date          *time.Time
	active_users         *int
	addactive_users      *int
	auth_transactions    *int
	addauth_transactions *int
	mfa_prompts          *int
	addmfa_prompts       *int
	machine_tokens       *int
	addmachine_tokens    *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*UsageMetric, error)
	predicates           []predicate.UsageMetric
}

var _ ent.Mutation = (*UsageMetricMutation)(nil)

// usagemetricOption allows management of the mutation configuration using functional options.
type usagemetricOption func(*UsageMetricMutation)

// newUsageMetricMutation creates new mutation for the UsageMetric entity.
func newUsageMetricMutation(c config, op Op, opts ...usagemetricOption) *UsageMetricMutation {
	m := &UsageMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageMetricID sets the ID field of the mutation.
func withUsageMetricID(id uuid.UUID) usagemetricOption {
	return func(m *UsageMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageMetric
		)
		m.oldValue = func(ctx context.Context) (*UsageMetric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageMetric sets the old UsageMetric of the mutation.
func withUsageMetric(node *UsageMetric) usagemetricOption {
	return func(m *UsageMetricMutation) {
		m.oldValue = func(context.Context) (*UsageMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsageMetric entities.
func (m *UsageMetricMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageMetricMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageMetricMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageMetric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UsageMetricMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UsageMetricMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UsageMetricMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetMetricDate sets the "metric_date" field.
func (m *UsageMetricMutation) SetMetricDate(t time.Time) {
	m.metric_date = &t
}

// MetricDate returns the value of the "metric_date" field in the mutation.
func (m *UsageMetricMutation) MetricDate() (r time.Time, exists bool) {
	v := m.metric_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMetricDate returns the old "metric_date" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldMetricDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetricDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetricDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetricDate: %w", err)
	}
	return oldValue.MetricDate, nil
}

// ResetMetricDate resets all changes to the "metric_date" field.
func (m *UsageMetricMutation) ResetMetricDate() {
	m.metric_date = nil
}

// SetActiveUsers sets the "active_users" field.
func (m *UsageMetricMutation) SetActiveUsers(i int) {
	m.active_users = &i
	m.addactive_users = nil
}

// ActiveUsers returns the value of the "active_users" field in the mutation.
func (m *UsageMetricMutation) ActiveUsers() (r int, exists bool) {
	v := m.active_users
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveUsers returns the old "active_users" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldActiveUsers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveUsers: %w", err)
	}
	return oldValue.ActiveUsers, nil
}

// AddActiveUsers adds i to the "active_users" field.
func (m *UsageMetricMutation) AddActiveUsers(i int) {
	if m.addactive_users != nil {
		*m.addactive_users += i
	} else {
		m.addactive_users = &i
	}
}

// AddedActiveUsers returns the value that was added to the "active_users" field in this mutation.
func (m *UsageMetricMutation) AddedActiveUsers() (r int, exists bool) {
	v := m.addactive_users
	if v == nil {
		return
	}
	return *v, true
}

// ResetActiveUsers resets all changes to the "active_users" field.
func (m *UsageMetricMutation) ResetActiveUsers() {
	m.active_users = nil
	m.addactive_users = nil
}

// SetAuthTransactions sets the "auth_transactions" field.
func (m *UsageMetricMutation) SetAuthTransactions(i int) {
	m.auth_transactions = &i
	m.addauth_transactions = nil
}

// AuthTransactions returns the value of the "auth_transactions" field in the mutation.
func (m *UsageMetricMutation) AuthTransactions() (r int, exists bool) {
	v := m.auth_transactions
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTransactions returns the old "auth_transactions" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldAuthTransactions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTransactions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTransactions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTransactions: %w", err)
	}
	return oldValue.AuthTransactions, nil
}

// AddAuthTransactions adds i to the "auth_transactions" field.
func (m *UsageMetricMutation) AddAuthTransactions(i int) {
	if m.addauth_transactions != nil {
		*m.addauth_transactions += i
	} else {
		m.addauth_transactions = &i
	}
}

// AddedAuthTransactions returns the value that was added to the "auth_transactions" field in this mutation.
func (m *UsageMetricMutation) AddedAuthTransactions() (r int, exists bool) {
	v := m.addauth_transactions
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthTransactions resets all changes to the "auth_transactions" field.
func (m *UsageMetricMutation) ResetAuthTransactions() {
	m.auth_transactions = nil
	m.addauth_transactions = nil
}

// SetMfaPrompts sets the "mfa_prompts" field.
func (m *UsageMetricMutation) SetMfaPrompts(i int) {
	m.mfa_prompts = &i
	m.addmfa_prompts = nil
}

// MfaPrompts returns the value of the "mfa_prompts" field in the mutation.
func (m *UsageMetricMutation) MfaPrompts() (r int, exists bool) {
	v := m.mfa_prompts
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaPrompts returns the old "mfa_prompts" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldMfaPrompts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaPrompts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaPrompts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaPrompts: %w", err)
	}
	return oldValue.MfaPrompts, nil
}

// AddMfaPrompts adds i to the "mfa_prompts" field.
func (m *UsageMetricMutation) AddMfaPrompts(i int) {
	if m.addmfa_prompts != nil {
		*m.addmfa_prompts += i
	} else {
		m.addmfa_prompts = &i
	}
}

// AddedMfaPrompts returns the value that was added to the "mfa_prompts" field in this mutation.
func (m *UsageMetricMutation) AddedMfaPrompts() (r int, exists bool) {
	v := m.addmfa_prompts
	if v == nil {
		return
	}
	return *v, true
}

// ResetMfaPrompts resets all changes to the "mfa_prompts" field.
func (m *UsageMetricMutation) ResetMfaPrompts() {
	m.mfa_prompts = nil
	m.addmfa_prompts = nil
}

// SetMachineTokens sets the "machine_tokens" field.
func (m *UsageMetricMutation) SetMachineTokens(i int) {
	m.machine_tokens = &i
	m.addmachine_tokens = nil
}

// MachineTokens returns the value of the "machine_tokens" field in the mutation.
func (m *UsageMetricMutation) MachineTokens() (r int, exists bool) {
	v := m.machine_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineTokens returns the old "machine_tokens" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldMachineTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachineTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachineTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineTokens: %w", err)
	}
	return oldValue.MachineTokens, nil
}

// AddMachineTokens adds i to the "machine_tokens" field.
func (m *UsageMetricMutation) AddMachineTokens(i int) {
	if m.addmachine_tokens != nil {
		*m.addmachine_tokens += i
	} else {
		m.addmachine_tokens = &i
	}
}

// AddedMachineTokens returns the value that was added to the "machine_tokens" field in this mutation.
func (m *UsageMetricMutation) AddedMachineTokens() (r int, exists bool) {
	v := m.addmachine_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetMachineTokens resets all changes to the "machine_tokens" field.
func (m *UsageMetricMutation) ResetMachineTokens() {
	m.machine_tokens = nil
	m.addmachine_tokens = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageMetric entity.
// If the UsageMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UsageMetricMutation builder.
func (m *UsageMetricMutation) Where(ps ...predicate.UsageMetric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageMetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageMetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageMetric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageMetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageMetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageMetric).
func (m *UsageMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageMetricMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant_id != nil {
		fields = append(fields, usagemetric.FieldTenantID)
	}
	if m.metric_date != nil {
		fields = append(fields, usagemetric.FieldMetricDate)
	}
	if m.active_users != nil {
		fields = append(fields, usagemetric.FieldActiveUsers)
	}
	if m.auth_transactions != nil {
		fields = append(fields, usagemetric.FieldAuthTransactions)
	}
	if m.mfa_prompts != nil {
		fields = append(fields, usagemetric.FieldMfaPrompts)
	}
	if m.machine_tokens != nil {
		fields = append(fields, usagemetric.FieldMachineTokens)
	}
	if m.created_at != nil {
		fields = append(fields, usagemetric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagemetric.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagemetric.FieldTenantID:
		return m.TenantID()
	case usagemetric.FieldMetricDate:
		return m.MetricDate()
	case usagemetric.FieldActiveUsers:
		return m.ActiveUsers()
	case usagemetric.FieldAuthTransactions:
		return m.AuthTransactions()
	case usagemetric.FieldMfaPrompts:
		return m.MfaPrompts()
	case usagemetric.FieldMachineTokens:
		return m.MachineTokens()
	case usagemetric.FieldCreatedAt:
		return m.CreatedAt()
	case usagemetric.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagemetric.FieldTenantID:
		return m.OldTenantID(ctx)
	case usagemetric.FieldMetricDate:
		return m.OldMetricDate(ctx)
	case usagemetric.FieldActiveUsers:
		return m.OldActiveUsers(ctx)
	case usagemetric.FieldAuthTransactions:
		return m.OldAuthTransactions(ctx)
	case usagemetric.FieldMfaPrompts:
		return m.OldMfaPrompts(ctx)
	case usagemetric.FieldMachineTokens:
		return m.OldMachineTokens(ctx)
	case usagemetric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagemetric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagemetric.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case usagemetric.FieldMetricDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetricDate(v)
		return nil
	case usagemetric.FieldActiveUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveUsers(v)
		return nil
	case usagemetric.FieldAuthTransactions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTransactions(v)
		return nil
	case usagemetric.FieldMfaPrompts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaPrompts(v)
		return nil
	case usagemetric.FieldMachineTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineTokens(v)
		return nil
	case usagemetric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagemetric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageMetricMutation) AddedFields() []string {
	var fields []string
	if m.addactive_users != nil {
		fields = append(fields, usagemetric.FieldActiveUsers)
	}
	if m.addauth_transactions != nil {
		fields = append(fields, usagemetric.FieldAuthTransactions)
	}
	if m.addmfa_prompts != nil {
		fields = append(fields, usagemetric.FieldMfaPrompts)
	}
	if m.addmachine_tokens != nil {
		fields = append(fields, usagemetric.FieldMachineTokens)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagemetric.FieldActiveUsers:
		return m.AddedActiveUsers()
	case usagemetric.FieldAuthTransactions:
		return m.AddedAuthTransactions()
	case usagemetric.FieldMfaPrompts:
		return m.AddedMfaPrompts()
	case usagemetric.FieldMachineTokens:
		return m.AddedMachineTokens()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagemetric.FieldActiveUsers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActiveUsers(v)
		return nil
	case usagemetric.FieldAuthTransactions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthTransactions(v)
		return nil
	case usagemetric.FieldMfaPrompts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMfaPrompts(v)
		return nil
	case usagemetric.FieldMachineTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMachineTokens(v)
		return nil
	}
	return fmt.Errorf("unknown UsageMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageMetricMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageMetricMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UsageMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageMetricMutation) ResetField(name string) error {
	switch name {
	case usagemetric.FieldTenantID:
		m.ResetTenantID()
		return nil
	case usagemetric.FieldMetricDate:
		m.ResetMetricDate()
		return nil
	case usagemetric.FieldActiveUsers:
		m.ResetActiveUsers()
		return nil
	case usagemetric.FieldAuthTransactions:
		m.ResetAuthTransactions()
		return nil
	case usagemetric.FieldMfaPrompts:
		m.ResetMfaPrompts()
		return nil
	case usagemetric.FieldMachineTokens:
		m.ResetMachineTokens()
		return nil
	case usagemetric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagemetric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageMetricMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageMetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageMetricMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageMetricMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UsageMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageMetricMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UsageMetric edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	email                        *string
	password_hash                *string
	status                       *string
	created_at                   *time.Time
	updated_at                   *time.Time
	primary_tenant_id            *string
	profile                      *map[string]interface{}
	last_login_at                *time.Time
	clearedFields                map[string]struct{}
	memberships                  map[uuid.UUID]struct{}
	removedmemberships           map[uuid.UUID]struct{}
	clearedmemberships           bool
	sessions                     map[uuid.UUID]struct{}
	removedsessions              map[uuid.UUID]struct{}
	clearedsessions              bool
	password_reset_tokens        map[uuid.UUID]struct{}
	removedpassword_reset_tokens map[uuid.UUID]struct{}
	clearedpassword_reset_tokens bool
	identities                   map[uuid.UUID]struct{}
	removedidentities            map[uuid.UUID]struct{}
	clearedidentities            bool
	authorization_codes          map[uuid.UUID]struct{}
	removedauthorization_codes   map[uuid.UUID]struct{}
	clearedauthorization_codes   bool
	mfa_totp                     map[uuid.UUID]struct{}
	removedmfa_totp              map[uuid.UUID]struct{}
	clearedmfa_totp              bool
	mfa_backup_codes             map[uuid.UUID]struct{}
	removedmfa_backup_codes      map[uuid.UUID]struct{}
	clearedmfa_backup_codes      bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPrimaryTenantID sets the "primary_tenant_id" field.
func (m *UserMutation) SetPrimaryTenantID(s string) {
	m.primary_tenant_id = &s
}

// PrimaryTenantID returns the value of the "primary_tenant_id" field in the mutation.
func (m *UserMutation) PrimaryTenantID() (r string, exists bool) {
	v := m.primary_tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryTenantID returns the old "primary_tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrimaryTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryTenantID: %w", err)
	}
	return oldValue.PrimaryTenantID, nil
}

// ClearPrimaryTenantID clears the value of the "primary_tenant_id" field.
func (m *UserMutation) ClearPrimaryTenantID() {
	m.primary_tenant_id = nil
	m.clearedFields[user.FieldPrimaryTenantID] = struct{}{}
}

// PrimaryTenantIDCleared returns if the "primary_tenant_id" field was cleared in this mutation.
func (m *UserMutation) PrimaryTenantIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrimaryTenantID]
	return ok
}

// ResetPrimaryTenantID resets all changes to the "primary_tenant_id" field.
func (m *UserMutation) ResetPrimaryTenantID() {
	m.primary_tenant_id = nil
	delete(m.clearedFields, user.FieldPrimaryTenantID)
}

// SetProfile sets the "profile" field.
func (m *UserMutation) SetProfile(value map[string]interface{}) {
	m.profile = &value
}

// Profile returns the value of the "profile" field in the mutation.
func (m *UserMutation) Profile() (r map[string]interface{}, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *UserMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[user.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *UserMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[user.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, user.FieldProfile)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// AddMembershipIDs adds the "memberships" edge to the TenantMembership entity by ids.
func (m *UserMutation) AddMembershipIDs(ids ...uuid.UUID) {
	if m.memberships == nil {
		m.memberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the TenantMembership entity.
func (m *UserMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the TenantMembership entity was cleared.
func (m *UserMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the TenantMembership entity by IDs.
func (m *UserMutation) RemoveMembershipIDs(ids ...uuid.UUID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the TenantMembership entity.
func (m *UserMutation) RemovedMembershipsIDs() (ids []uuid.UUID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *UserMutation) MembershipsIDs() (ids []uuid.UUID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *UserMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m.sessions == nil {
		m.sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by ids.
func (m *UserMutation) AddPasswordResetTokenIDs(ids ...uuid.UUID) {
	if m.password_reset_tokens == nil {
		m.password_reset_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.password_reset_tokens[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetTokens clears the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) ClearPasswordResetTokens() {
	m.clearedpassword_reset_tokens = true
}

// PasswordResetTokensCleared reports if the "password_reset_tokens" edge to the PasswordResetToken entity was cleared.
func (m *UserMutation) PasswordResetTokensCleared() bool {
	return m.clearedpassword_reset_tokens
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (m *UserMutation) RemovePasswordResetTokenIDs(ids ...uuid.UUID) {
	if m.removedpassword_reset_tokens == nil {
		m.removedpassword_reset_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.password_reset_tokens, ids[i])
		m.removedpassword_reset_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetTokens returns the removed IDs of the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) RemovedPasswordResetTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedpassword_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// PasswordResetTokensIDs returns the "password_reset_tokens" edge IDs in the mutation.
func (m *UserMutation) PasswordResetTokensIDs() (ids []uuid.UUID) {
	for id := range m.password_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetTokens resets all changes to the "password_reset_tokens" edge.
func (m *UserMutation) ResetPasswordResetTokens() {
	m.password_reset_tokens = nil
	m.clearedpassword_reset_tokens = false
	m.removedpassword_reset_tokens = nil
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...uuid.UUID) {
	if m.identities == nil {
		m.identities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...uuid.UUID) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddAuthorizationCodeIDs adds the "authorization_codes" edge to the AuthorizationCode entity by ids.
func (m *UserMutation) AddAuthorizationCodeIDs(ids ...uuid.UUID) {
	if m.authorization_codes == nil {
		m.authorization_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.authorization_codes[ids[i]] = struct{}{}
	}
}

// ClearAuthorizationCodes clears the "authorization_codes" edge to the AuthorizationCode entity.
func (m *UserMutation) ClearAuthorizationCodes() {
	m.clearedauthorization_codes = true
}

// AuthorizationCodesCleared reports if the "authorization_codes" edge to the AuthorizationCode entity was cleared.
func (m *UserMutation) AuthorizationCodesCleared() bool {
	return m.clearedauthorization_codes
}

// RemoveAuthorizationCodeIDs removes the "authorization_codes" edge to the AuthorizationCode entity by IDs.
func (m *UserMutation) RemoveAuthorizationCodeIDs(ids ...uuid.UUID) {
	if m.removedauthorization_codes == nil {
		m.removedauthorization_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.authorization_codes, ids[i])
		m.removedauthorization_codes[ids[i]] = struct{}{}
	}
}

// RemovedAuthorizationCodes returns the removed IDs of the "authorization_codes" edge to the AuthorizationCode entity.
func (m *UserMutation) RemovedAuthorizationCodesIDs() (ids []uuid.UUID) {
	for id := range m.removedauthorization_codes {
		ids = append(ids, id)
	}
	return
}

// AuthorizationCodesIDs returns the "authorization_codes" edge IDs in the mutation.
func (m *UserMutation) AuthorizationCodesIDs() (ids []uuid.UUID) {
	for id := range m.authorization_codes {
		ids = append(ids, id)
	}
	return
}

// ResetAuthorizationCodes resets all changes to the "authorization_codes" edge.
func (m *UserMutation) ResetAuthorizationCodes() {
	m.authorization_codes = nil
	m.clearedauthorization_codes = false
	m.removedauthorization_codes = nil
}

// AddMfaTotpIDs adds the "mfa_totp" edge to the MFATOTPSecret entity by ids.
func (m *UserMutation) AddMfaTotpIDs(ids ...uuid.UUID) {
	if m.mfa_totp == nil {
		m.mfa_totp = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mfa_totp[ids[i]] = struct{}{}
	}
}

// ClearMfaTotp clears the "mfa_totp" edge to the MFATOTPSecret entity.
func (m *UserMutation) ClearMfaTotp() {
	m.clearedmfa_totp = true
}

// MfaTotpCleared reports if the "mfa_totp" edge to the MFATOTPSecret entity was cleared.
func (m *UserMutation) MfaTotpCleared() bool {
	return m.clearedmfa_totp
}

// RemoveMfaTotpIDs removes the "mfa_totp" edge to the MFATOTPSecret entity by IDs.
func (m *UserMutation) RemoveMfaTotpIDs(ids ...uuid.UUID) {
	if m.removedmfa_totp == nil {
		m.removedmfa_totp = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mfa_totp, ids[i])
		m.removedmfa_totp[ids[i]] = struct{}{}
	}
}

// RemovedMfaTotp returns the removed IDs of the "mfa_totp" edge to the MFATOTPSecret entity.
func (m *UserMutation) RemovedMfaTotpIDs() (ids []uuid.UUID) {
	for id := range m.removedmfa_totp {
		ids = append(ids, id)
	}
	return
}

// MfaTotpIDs returns the "mfa_totp" edge IDs in the mutation.
func (m *UserMutation) MfaTotpIDs() (ids []uuid.UUID) {
	for id := range m.mfa_totp {
		ids = append(ids, id)
	}
	return
}

// ResetMfaTotp resets all changes to the "mfa_totp" edge.
func (m *UserMutation) ResetMfaTotp() {
	m.mfa_totp = nil
	m.clearedmfa_totp = false
	m.removedmfa_totp = nil
}

// AddMfaBackupCodeIDs adds the "mfa_backup_codes" edge to the MFABackupCode entity by ids.
func (m *UserMutation) AddMfaBackupCodeIDs(ids ...uuid.UUID) {
	if m.mfa_backup_codes == nil {
		m.mfa_backup_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mfa_backup_codes[ids[i]] = struct{}{}
	}
}

// ClearMfaBackupCodes clears the "mfa_backup_codes" edge to the MFABackupCode entity.
func (m *UserMutation) ClearMfaBackupCodes() {
	m.clearedmfa_backup_codes = true
}

// MfaBackupCodesCleared reports if the "mfa_backup_codes" edge to the MFABackupCode entity was cleared.
func (m *UserMutation) MfaBackupCodesCleared() bool {
	return m.clearedmfa_backup_codes
}

// RemoveMfaBackupCodeIDs removes the "mfa_backup_codes" edge to the MFABackupCode entity by IDs.
func (m *UserMutation) RemoveMfaBackupCodeIDs(ids ...uuid.UUID) {
	if m.removedmfa_backup_codes == nil {
		m.removedmfa_backup_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mfa_backup_codes, ids[i])
		m.removedmfa_backup_codes[ids[i]] = struct{}{}
	}
}

// RemovedMfaBackupCodes returns the removed IDs of the "mfa_backup_codes" edge to the MFABackupCode entity.
func (m *UserMutation) RemovedMfaBackupCodesIDs() (ids []uuid.UUID) {
	for id := range m.removedmfa_backup_codes {
		ids = append(ids, id)
	}
	return
}

// MfaBackupCodesIDs returns the "mfa_backup_codes" edge IDs in the mutation.
func (m *UserMutation) MfaBackupCodesIDs() (ids []uuid.UUID) {
	for id := range m.mfa_backup_codes {
		ids = append(ids, id)
	}
	return
}

// ResetMfaBackupCodes resets all changes to the "mfa_backup_codes" edge.
func (m *UserMutation) ResetMfaBackupCodes() {
	m.mfa_backup_codes = nil
	m.clearedmfa_backup_codes = false
	m.removedmfa_backup_codes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.primary_tenant_id != nil {
		fields = append(fields, user.FieldPrimaryTenantID)
	}
	if m.profile != nil {
		fields = append(fields, user.FieldProfile)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldStatus:
		return m.Status()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldPrimaryTenantID:
		return m.PrimaryTenantID()
	case user.FieldProfile:
		return m.Profile()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldPrimaryTenantID:
		return m.OldPrimaryTenantID(ctx)
	case user.FieldProfile:
		return m.OldProfile(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldPrimaryTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryTenantID(v)
		return nil
	case user.FieldProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldPrimaryTenantID) {
		fields = append(fields, user.FieldPrimaryTenantID)
	}
	if m.FieldCleared(user.FieldProfile) {
		fields = append(fields, user.FieldProfile)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldPrimaryTenantID:
		m.ClearPrimaryTenantID()
		return nil
	case user.FieldProfile:
		m.ClearProfile()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldPrimaryTenantID:
		m.ResetPrimaryTenantID()
		return nil
	case user.FieldProfile:
		m.ResetProfile()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.memberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.password_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.authorization_codes != nil {
		edges = append(edges, user.EdgeAuthorizationCodes)
	}
	if m.mfa_totp != nil {
		edges = append(edges, user.EdgeMfaTotp)
	}
	if m.mfa_backup_codes != nil {
		edges = append(edges, user.EdgeMfaBackupCodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.password_reset_tokens))
		for id := range m.password_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthorizationCodes:
		ids := make([]ent.Value, 0, len(m.authorization_codes))
		for id := range m.authorization_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaTotp:
		ids := make([]ent.Value, 0, len(m.mfa_totp))
		for id := range m.mfa_totp {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaBackupCodes:
		ids := make([]ent.Value, 0, len(m.mfa_backup_codes))
		for id := range m.mfa_backup_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmemberships != nil {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedpassword_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedauthorization_codes != nil {
		edges = append(edges, user.EdgeAuthorizationCodes)
	}
	if m.removedmfa_totp != nil {
		edges = append(edges, user.EdgeMfaTotp)
	}
	if m.removedmfa_backup_codes != nil {
		edges = append(edges, user.EdgeMfaBackupCodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_tokens))
		for id := range m.removedpassword_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuthorizationCodes:
		ids := make([]ent.Value, 0, len(m.removedauthorization_codes))
		for id := range m.removedauthorization_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaTotp:
		ids := make([]ent.Value, 0, len(m.removedmfa_totp))
		for id := range m.removedmfa_totp {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMfaBackupCodes:
		ids := make([]ent.Value, 0, len(m.removedmfa_backup_codes))
		for id := range m.removedmfa_backup_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmemberships {
		edges = append(edges, user.EdgeMemberships)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedpassword_reset_tokens {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedauthorization_codes {
		edges = append(edges, user.EdgeAuthorizationCodes)
	}
	if m.clearedmfa_totp {
		edges = append(edges, user.EdgeMfaTotp)
	}
	if m.clearedmfa_backup_codes {
		edges = append(edges, user.EdgeMfaBackupCodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMemberships:
		return m.clearedmemberships
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgePasswordResetTokens:
		return m.clearedpassword_reset_tokens
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeAuthorizationCodes:
		return m.clearedauthorization_codes
	case user.EdgeMfaTotp:
		return m.clearedmfa_totp
	case user.EdgeMfaBackupCodes:
		return m.clearedmfa_backup_codes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgePasswordResetTokens:
		m.ResetPasswordResetTokens()
		return nil
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeAuthorizationCodes:
		m.ResetAuthorizationCodes()
		return nil
	case user.EdgeMfaTotp:
		m.ResetMfaTotp()
		return nil
	case user.EdgeMfaBackupCodes:
		m.ResetMfaBackupCodes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	provider         *string
	provider_subject *string
	provider_email   *string
	email_verified   *bool
	access_token     *string
	refresh_token    *string
	token_expiry     *time.Time
	scope            *string
	profile          *map[string]interface{}
	linked_at        *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*UserIdentity, error)
	predicates       []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id uuid.UUID) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
}

// SetProvider sets the "provider" field.
func (m *UserIdentityMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserIdentityMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserIdentityMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderSubject sets the "provider_subject" field.
func (m *UserIdentityMutation) SetProviderSubject(s string) {
	m.provider_subject = &s
}

// ProviderSubject returns the value of the "provider_subject" field in the mutation.
func (m *UserIdentityMutation) ProviderSubject() (r string, exists bool) {
	v := m.provider_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderSubject returns the old "provider_subject" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProviderSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderSubject: %w", err)
	}
	return oldValue.ProviderSubject, nil
}

// ResetProviderSubject resets all changes to the "provider_subject" field.
func (m *UserIdentityMutation) ResetProviderSubject() {
	m.provider_subject = nil
}

// SetProviderEmail sets the "provider_email" field.
func (m *UserIdentityMutation) SetProviderEmail(s string) {
	m.provider_email = &s
}

// ProviderEmail returns the value of the "provider_email" field in the mutation.
func (m *UserIdentityMutation) ProviderEmail() (r string, exists bool) {
	v := m.provider_email
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderEmail returns the old "provider_email" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProviderEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderEmail: %w", err)
	}
	return oldValue.ProviderEmail, nil
}

// ResetProviderEmail resets all changes to the "provider_email" field.
func (m *UserIdentityMutation) ResetProviderEmail() {
	m.provider_email = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserIdentityMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserIdentityMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserIdentityMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetAccessToken sets the "access_token" field.
func (m *UserIdentityMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *UserIdentityMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *UserIdentityMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[useridentity.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *UserIdentityMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *UserIdentityMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, useridentity.FieldAccessToken)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *UserIdentityMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *UserIdentityMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *UserIdentityMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[useridentity.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *UserIdentityMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *UserIdentityMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, useridentity.FieldRefreshToken)
}

// SetTokenExpiry sets the "token_expiry" field.
func (m *UserIdentityMutation) SetTokenExpiry(t time.Time) {
	m.token_expiry = &t
}

// TokenExpiry returns the value of the "token_expiry" field in the mutation.
func (m *UserIdentityMutation) TokenExpiry() (r time.Time, exists bool) {
	v := m.token_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiry returns the old "token_expiry" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldTokenExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiry: %w", err)
	}
	return oldValue.TokenExpiry, nil
}

// ClearTokenExpiry clears the value of the "token_expiry" field.
func (m *UserIdentityMutation) ClearTokenExpiry() {
	m.token_expiry = nil
	m.clearedFields[useridentity.FieldTokenExpiry] = struct{}{}
}

// TokenExpiryCleared returns if the "token_expiry" field was cleared in this mutation.
func (m *UserIdentityMutation) TokenExpiryCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldTokenExpiry]
	return ok
}

// ResetTokenExpiry resets all changes to the "token_expiry" field.
func (m *UserIdentityMutation) ResetTokenExpiry() {
	m.token_expiry = nil
	delete(m.clearedFields, useridentity.FieldTokenExpiry)
}

// SetScope sets the "scope" field.
func (m *UserIdentityMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *UserIdentityMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *UserIdentityMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[useridentity.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *UserIdentityMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *UserIdentityMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, useridentity.FieldScope)
}

// SetProfile sets the "profile" field.
func (m *UserIdentityMutation) SetProfile(value map[string]interface{}) {
	m.profile = &value
}

// Profile returns the value of the "profile" field in the mutation.
func (m *UserIdentityMutation) Profile() (r map[string]interface{}, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *UserIdentityMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[useridentity.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *UserIdentityMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *UserIdentityMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, useridentity.FieldProfile)
}

// SetLinkedAt sets the "linked_at" field.
func (m *UserIdentityMutation) SetLinkedAt(t time.Time) {
	m.linked_at = &t
}

// LinkedAt returns the value of the "linked_at" field in the mutation.
func (m *UserIdentityMutation) LinkedAt() (r time.Time, exists bool) {
	v := m.linked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedAt returns the old "linked_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldLinkedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedAt: %w", err)
	}
	return oldValue.LinkedAt, nil
}

// ResetLinkedAt resets all changes to the "linked_at" field.
func (m *UserIdentityMutation) ResetLinkedAt() {
	m.linked_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.provider != nil {
		fields = append(fields, useridentity.FieldProvider)
	}
	if m.provider_subject != nil {
		fields = append(fields, useridentity.FieldProviderSubject)
	}
	if m.provider_email != nil {
		fields = append(fields, useridentity.FieldProviderEmail)
	}
	if m.email_verified != nil {
		fields = append(fields, useridentity.FieldEmailVerified)
	}
	if m.access_token != nil {
		fields = append(fields, useridentity.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, useridentity.FieldRefreshToken)
	}
	if m.token_expiry != nil {
		fields = append(fields, useridentity.FieldTokenExpiry)
	}
	if m.scope != nil {
		fields = append(fields, useridentity.FieldScope)
	}
	if m.profile != nil {
		fields = append(fields, useridentity.FieldProfile)
	}
	if m.linked_at != nil {
		fields = append(fields, useridentity.FieldLinkedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldProvider:
		return m.Provider()
	case useridentity.FieldProviderSubject:
		return m.ProviderSubject()
	case useridentity.FieldProviderEmail:
		return m.ProviderEmail()
	case useridentity.FieldEmailVerified:
		return m.EmailVerified()
	case useridentity.FieldAccessToken:
		return m.AccessToken()
	case useridentity.FieldRefreshToken:
		return m.RefreshToken()
	case useridentity.FieldTokenExpiry:
		return m.TokenExpiry()
	case useridentity.FieldScope:
		return m.Scope()
	case useridentity.FieldProfile:
		return m.Profile()
	case useridentity.FieldLinkedAt:
		return m.LinkedAt()
	case useridentity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldProvider:
		return m.OldProvider(ctx)
	case useridentity.FieldProviderSubject:
		return m.OldProviderSubject(ctx)
	case useridentity.FieldProviderEmail:
		return m.OldProviderEmail(ctx)
	case useridentity.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case useridentity.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case useridentity.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case useridentity.FieldTokenExpiry:
		return m.OldTokenExpiry(ctx)
	case useridentity.FieldScope:
		return m.OldScope(ctx)
	case useridentity.FieldProfile:
		return m.OldProfile(ctx)
	case useridentity.FieldLinkedAt:
		return m.OldLinkedAt(ctx)
	case useridentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case useridentity.FieldProviderSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderSubject(v)
		return nil
	case useridentity.FieldProviderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderEmail(v)
		return nil
	case useridentity.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case useridentity.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case useridentity.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case useridentity.FieldTokenExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiry(v)
		return nil
	case useridentity.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case useridentity.FieldProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case useridentity.FieldLinkedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedAt(v)
		return nil
	case useridentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldAccessToken) {
		fields = append(fields, useridentity.FieldAccessToken)
	}
	if m.FieldCleared(useridentity.FieldRefreshToken) {
		fields = append(fields, useridentity.FieldRefreshToken)
	}
	if m.FieldCleared(useridentity.FieldTokenExpiry) {
		fields = append(fields, useridentity.FieldTokenExpiry)
	}
	if m.FieldCleared(useridentity.FieldScope) {
		fields = append(fields, useridentity.FieldScope)
	}
	if m.FieldCleared(useridentity.FieldProfile) {
		fields = append(fields, useridentity.FieldProfile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case useridentity.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case useridentity.FieldTokenExpiry:
		m.ClearTokenExpiry()
		return nil
	case useridentity.FieldScope:
		m.ClearScope()
		return nil
	case useridentity.FieldProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldProvider:
		m.ResetProvider()
		return nil
	case useridentity.FieldProviderSubject:
		m.ResetProviderSubject()
		return nil
	case useridentity.FieldProviderEmail:
		m.ResetProviderEmail()
		return nil
	case useridentity.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case useridentity.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case useridentity.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case useridentity.FieldTokenExpiry:
		m.ResetTokenExpiry()
		return nil
	case useridentity.FieldScope:
		m.ResetScope()
		return nil
	case useridentity.FieldProfile:
		m.ResetProfile()
		return nil
	case useridentity.FieldLinkedAt:
		m.ResetLinkedAt()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}
